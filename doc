
فصل اول
مقدمه




بیت کوین یکی از ده ها ارز رمز ی است که اکنون در حال استفاده است .
می توان گفت بیت کوین اولین ارز رمز تولید شده است که ایده ی آن انتقال پول و انجام تراکنش  ها بر اساس یک ساختار غیر متمرکز  است.
 
شکل 1-1 نماد بیت کوین
غیر متمرکز به این معنا که اطلاعات می تواند دست هر فردی باشد و مکان خاصی برای ذخیره ی اطلاعات وجود ندارد.
برتری غیر متمرکز بودن آن در این است که اگر فردی بخواهد در اطلاعات خدشه وارد کند ، چندین کپی دیگر از آن موجود است مشکلی برای اطلاعات ایجاد نمی شود .
از نظر دیگر غیر قابل کنترل بودن این ساختار توسط قدرت هاست که یک برتری دیگر حساب می شود.
مابقی ارز رمز ها  هم بر اساس ایده ی بیت کوین ساخته شده اند با تغییراتی در نام ها و یا تغییراتی در الگوریتم ماینینگ  آن ها.
حتی بعضی ارز رمز ها هیچ تغییری در الگوریتم ها نداده اند و فقط نام خود را تغییر داده اند . مانند namecoin  و bitcoin cash
مخترع آن فرد ناشناسی به نام ساتوشی ناکاماتو است که هدف خود را از این کار ،آزادی در انجام تراکنش ها و جلوگیری از دست اندازی قدرت ها در انجام تراکنش های بانکی و یا انجام نشدن آن ها (تحریم کشور ها ) قرار داده.
اگر بانک ها را به عنوان یک ساختار متمرکز در نظر بگیریم به این معنا که یک سرور دارند که اطلاعات تمام مشتریان در آن قرار دارد و اختیار بلوکه کردن و باز کردن حساب و انجام تراکنش ها به دست بانک خواهد بود .
اما بیت کوین را می توان یک بانک در نظر گرفت که اطلاعات مشتریان در اختیار هر کسی می تواند قرار بگیرد ولی به علت عملیاتی که روی تراکنش های بیت کوینی (که به آن ماینینگ می گویند) انجام می شود  ، کسی نمی تواند اطلاعات آن را تغییر دهد و به عنوان مثال دارایی های فردی را بدزدد.
مساله ی اول در استفاده از پول اینست که کجا آن را نگهداری می کنند.
در یک بانک شما دارایی خود را در حساب نگه می دارید . پول را می دهید و تنها چند عدد و رقم در دفترچه ی خود یا در همراه بانک خود تحویل می گیرید.
ارز رمز ها یک دارایی اند مانند یک همراه بانک بر روی لینوکس یا pc یا تلفن همراه در نرم افزاری که به آن کیف پول می گویند ثبت می شوند.
دقیقا همانند انجام یک تراکنش حساب به حساب بانکی که به واسطه ی داشتن شماره حساب می توانید ارز منتقل کنید ، در یک کیف پول یا wallet نیز در صورت داشتن آدرس کیف پول طرف مقابل برای او ارز رمز بفرستید.
خیلی ها این سوال برایشان پیش می آید که ارزش گذاری آن به چه صورت انجام می شود ؟ پشتوانه ای دارد یا خیر .
1.	دلار و یورو ارز های بدون پشتوانه ای هستند که تنها ارزش آن ها را قدرتشان در انجام معاملات به وسیله ی آن ها تعیین می کند. پس اگر بیت کوین پشتوانه ای نداشته باشد نباید تعجب کرد .
2.	بسیاری معتقدند انرژی پشتوانه ی بیت کوین می باشد زیرا انرژی هنگفتی در تایید معاملات مصرف می شود.
3.	روش هایی در بازار بیت کوین برای کاهش عرضه مانند joincoin وجود دارد که باعث بالا رفتن ارزش بیت کوین می شود.
شاید بپرسید بیت کوین ها از کجا می آیند . باید گفت دقیقا همانند پول ها که هر روز چاپ می شوند، روزانه چند وعده به صورت دیجیتالی  بیت کوین های تازه ایجاد شده به کیف پول تایید کنندگان تراکنش ها ی بیت کوینی واریز می شود و آن ها با خرج کردن این بیت کوین ها یعنی فرستادن آن ها به کیف پول بقیه در ازای دریافت خدمت ، آن را وارد پهنه ی معاملات می کنند.
در بانک ها ، تایید تراکنش شاید در حد چک کردن صحیح بودن شماره حساب ها باشد ولی در مورد ارزرمز باید گفت چون فردی بر آن و راستی آزمایی آن نظارت ندارد(که بانک ها این وظیفه را در مورد ارز های حقیقی انجام می دهند.) باید روشی برای تایید تراکنش ها وجود داشته باشد . به افرادی که چنین کاری انجام میدهند ماینر  یا معدن کاو می گویند.
ماینر ها هر کدام دارای چندین دستگاه هستند که از قبل تنها برای همین کار برنامه ریزی شده .
البته قبلا از cpu ها   و gpu ها و fpga ها که قابل برنامه ریزی بودند استفاده می شد ولی بسیار کم بهره بودند .
برای همین دستگاه های تک منظوره  ای ساخته شدند تنها برای همین کار که مانند fpga ها طراحی می شوند و شرکت های خاصی هستند که آن ها را با توجه به طراحی شما تولید می کنند . این دستگاه های تک منظوره از نوع asic هستند.
من در این پروژه سعی کرده ام مقدمات ساخت یک ماینر با fpga را فراهم کنم . با اینکه از سال 2013 به بعد از این روش برای بیت کوین دست کشیده شده به علت به وجود آمدن دستگاه های بهتر و حتی توصیه شده بود این کار به هیچ عنوان بهینه نیست ، اما من به چند علت دست به چنین کاری زدم :
1.	علاقه به دانستن نحوه ی کار با بیت کوین و نحوه ی انجام عملیات ماینینگ
2.	افزایش آگاهی جامعه از نحوه ی استفاده از آن و خطرات موجود
3.	شاید این طراحی زمینه سازی باشد بر ساخت دستگاه های بهتر














فصل دوم
اصطلاحات




برای شروع کار با بیت کوین باید با نام و معنای بعضی لغات نو آورانه در این حوزه آشنایی پیدا کرد. در ادامه کلی ترین لغات مربوط به بحث آورده می شوند.

1-2- بیت کوین کور(bitcoin core )
نرم افزاری که ناکاماتو به زبان c و در محیط qt نوشته و منبع  آن را می توان در github.com/bitcoin/bitcoin  پیدا کرد .
این برنامه شامل تمام آن چیزی است که بیت کوین بر اساس آن کار می کند که در سال 2008  نمونه ی اولیه ی آن عرضه شده .
بیت کوین کور شامل :
1.	کیف پول (wallet) است که می توان آن را مثل یک حساب بانکی دانست  که تمام دارایی فرد در آن ذخیره می شود و می توان از طریق آن تراکنش (transaction)  انجام داد(برای فرد دیگری بیت کوین فرستاد )
2.	برنامه هایی برای بارگیری  اطلاعات تراکنش های بیت کوینی (بلاکچین) از افراد دیگری که این اطلاعات را ذخیره دارند
3.	برنامه هایی برای تایید تراکنش ها
4.	برنامه هایی برای دادن اطلاعات مورد نیاز برای انجام عملیات( mining)
5.	و...
است.
2-2- Bitcoind
نصب بیت کوین کور چهار زیر برنامه ی قابل اجرا  که دو قسمت آن client و bitcoind است.
Bitcoind اطلاعات بلاکچین را دارا ست و برای گرفتن اطلاعات یا ارسال اطلاعات به بلاکچین با استفاده از دستور  های json_rpc  انجام می شود.
3-2 bitcoin-cli
به هر گره دارای اطلاعات بلاکچین یک  کلاینت می گویند. بعضا گره  و کلاینت  به جای هم استفاده می شوند.
کلاینت قسمتی از بیت کوین کور است که یک json-rpc داخلی دارد و وظیفه ی ارسال تراکنش ها و دریافت دارایی از بلاکچین را دارد.
همچنین این زیر برنامه برای ارسال دستور های json rpc در محیط cmd استفاده می شود.
شایان ذکر است که از نسخه  0.5 به بعد bitcoind  به بیت کوین کور پیوسته و از ابتدا تنها client  وجود داشته.
client  ها سه دسته اند :
1.	Full
2.	Light
3.	Web
دسته ی اول تمام اطلاعات بیت کوین را دارا می باشند که اکنون نزدیک به 400 گیگابایت حافظه  نیاز دارد
دسته ی دوم تنها اطلاعات فعلی مورد نیاز برای انجام عملیات ماینینگ و یا انجام تراکنش را در خور ذخیره می کند که یعنی مصرف پهنای باند کمتر و حافظه ی کمتر
دسته ی سوم کیف پول را آنلاین نگهداری می کنند و اطلاعات را از طریق اینترنت بدون نصب هیچ نرم افزاری در اختیار فرد قرار می دهند.
چند full client عبارتند از :bitcoin core , armory ,
و یک light client:  electrum
که armory  دیگر کاربردی ندارد چون پروژه توسط گروهی که روی آن کار می کردند متوقف شده.
بعد از نصب بیت کوین کور به صورت build  کردن (مخصوص توسعه دهندگان) و یا دانلود نرم افزار و نصب آن، می توان به دو صورت برنامه را اجرا کرد . یا با command prompt  و یا با اجرا کردن فایل exe.
وقتی client  اجرا می شود شروع می کند به دانلود کردن اطلاعات حاوی بلاکچین که در حالت عادی دانلود کردن آن بسیار زمان بر است .
برای ذخیره کردن زمان و مصرف اینترنت می توان اطلاعات بلاکچین را از کسی که قبلا آن را دانلود کرده گرفت و بر روی سیستم قرار داد. نحوه ی انجام این عملیات در https://en.bitcoin.it/wiki/Data_directory
توضیح داده شده.
بیت کوین کور به دو صورت گرافیکی  و دستوری داخل محیط cmd  قابل استفاده است . مثال هایی از دستور ها در این پایان نامه آمده است .
لیستی از دستور ها را می توانید در
https://en.bitcoin.it/wiki/Running_Bitcoin
بیابید .

4-2BIP
مخفف Bitcoin Improvement Proposal سند هایی هستند که توسعه دهندگان بیت کوین ،در آدرس github.com/bitcoin/bips  منشر می کنند که بعضی شامل تغییراتی است که در کد بیت کوین کور در طول زمان اتفاق افتاده و یا شامل پیشنهاداتی به توسعه دهنگان غیر ،برای تولید نرم افزار های جانبی بیت کوین است.
مثال :bip-0034  شامل تغییراتی است که در به روزرسانی نسخه 1 به 2 در نحوه ی تشکیل بلوک ها رخ داده است.
توضیحات بیشتر در:
https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki
خواندن این فایل ها به همراه release note ها به توسعه دهنگان بسیار کمک می کند. release note ها را می توان در محیط github پیدا کرد.

5-2  Blockchain
این واژه از دو کلمه تشکیل می شود :  block و chain
به معنای بلوک و زنجیر یعنی بلوک هایی که به یکدیگر زنجیر شده اند . زنجیر شدن بلوک ها به این معنا که اطلاعات بلوک قبلی در تشکیل بلوک جدید استفاده شده و به همین علت، تغییر دادن یکی از بلوک های قبلی(زیری) فقط به این شرط امکان پذیر خواهد بود که بلوک های بالاتر(جدید) از آن را تغییر دهیم.
بلوک ها حاوی اطلاعات تراکنش ها هستند.
بلوک ها را با استفاده از شماره ی آن ها و یا هش آن ها می شناسند . البته به دلایلی که بعدا به آن می پردازیم استفاده از شماره ی بلوک استاندارد نیست.
در ساختار بیت کوین بلوک ها به طور میانگین هر ده دقیقه یکبار تشکیل می شوند.
این فاصله ی زمانی توسط یک الگوریتم داخل برنامه نویسی بیت کوین کور کنترل می شود.
با تشکیل  هر بلوک ، بلوک جدید بر روی بلوک قبلی قرار می گیرد.
با تشکیل یک بلوک ، تراکنش هایی که داخل آن قرار گرفته اند تایید  می شوند و قابل خرج کردن  توسط صاحب آن می شود .
به اولین روز اجرای بلاکچین genesis می گویند که همان روزی است که بلوک شماره 1 تشکیل شده است که به آن genesis block می گویند.
بلاکچین بر اساس قوانینی جلو میرود از جمله قوانینی در مورد چگونگی کارکرد کیف پول ها و انجام تراکنش ها ، چگونگی انجام عملیات ماینینگ و تایید تراکنش ها و ...
به این قوانین در سند  های بیت کوین consensus  گفته می شود.
در مورد این قوانین بعدا بحث خواهد شد.

6-2 هش 
این کلمه را شاید چندین بار در حین مطالعه  بیت کوین و یا هر ارز رمز دیگر با آن مواجه شوید .
اگر با رمزنگاری  آشنایی داشته باشید می دانید که یک دانش است برای تولید رمز هایی که احتمال شکستن آن ها بسیار کم باشد .
برای این کار الگوریتم هایی تهیه می کنند . یکی از انواع رمزنگاری hash می باشد.
به این موضوع باید توجه کرد که اگر یک رمزنگاری قابل شکستن  باشد یعنی بتوانیم از خروجی به ورودی برسیم دیگر آن رمزنگاری قابل استفاده نخواهد بود .
در مورد هش باید گفت به علت وجود چند شیفت غیر چرخشی در الگوریتم هش ها و انجام عمل جمع بدون نقلی ،عملا مقداری از اطلاعات ورودی از بین می رود و ورودی قابل دستیابی نخواهد بود .
در رمزنگاری سعی می شود که در صورت داشتن دو ورودی متفاوت ، دو خروجی  متفاوت داشته باشیم . و در صورت پی بردن به دو ورودی متفاوت که خروجی یکسان تولید می کند ، یک مشکل برای آن رمزنگاری تلقی می شود.
هش ،در صورت داشتن ورودی با هر چند مقدار سایز ، خروجی با سایز یکسان می دهد .
هش استفاده شده در پروسه ی ماینینگ (معدن کاوی) sha256 از خانواده ی sha2  می باشد.

7-2 واحد های کسری بیت کوین
 
شکل 1-2 واحد های کسری بیت کوین

8-2 Peer to peer
این اصطلاح اولین اصطلاحی است که در هر ابتدای هر سندی مربوط به بیت کوین با آن مواجه می شوید.
از آنجایی که بلاکچین غیر متمرکز است ، اطلاعات آن در دست هر فردی می تواند باشد. هر جایی که اطلاعات بلاکچین را دارا ست به آن یک گره(node) می گویند .
هر فردی که بخواهد کلاینت را نصب کند ، ابتدا باید بلاکچین را دانلود کند (خودکار) حال سوال اینجاست که اگر سروری موجود نیست ، اطلاعات از کجا دانلود می شود .
جواب اینجاست ارتباط peer to peer است. اطلاعات را از یک گره دیگر دریافت خواهید کرد . یعنی از فرد یا افرادی که قبلا آن را دانلود کرده اند.
 
شکل 2-2 ساختار peer to peer
9-2 تراکنش
برای جلو گیری از گیج شدن باید ابتدا نحوه ی انجام تراکنش و تایید آن توسط بلاکچین و ماینر ها توضیح داده شود .
فرض کنید می خواهید در ازای خرید یک پیراهن به فروشنده بیت کوین بدهید ( البته معادل ریالی آن را) .
برای این کار، فروشنده و شما بر روی موبایل خود(یا هر وسیله ی دیگر) کیف پول دارید .
شما در کیف پول خود بایست مقداری بیشتر از مقدار درخواستی فروشنده داشته باشید که به عنوان دستمزد (جایزه) به افرادی می دهید که تراکنش شما را تایید می کنند.(ماینر ها(miners))
فروشنده با کیف پول خود  باید یک آدرس تولید کند (در بعضی کیف پول ها خود به خود تولید می شود) که شما به آن آدرس، هزینه ی پیراهن را به همراه مقدار جایزه (fee) میفرستید.
این آدرس می تواند به صورت یک بارکد در صفحه ی نمایشگری مقابل شما ظاهر شود.
شما آن را اسکن می کنید و آدرس فروشنده را که بسیار طولانی ست وارد تلفن همراه خود می کنید
بلاکچین بعدا خودش fee را به ماینر خواهد داد.
توجه : مقدار fee  به دست پرداخت کننده است. حتی می توان مقدار fee تعیین نکرد ولی ماینر ها هستند که بر اساس مقدار fee اولویت می دهند که تراکنشی را تایید کنند یا خیر.
پس قرار ندادن یا کم قراردادن fee  به معنای کاهش احتمال تایید شدن تراکنش خواهد بود .
توجه: مقدار fee  درصد کوچکی در مقابل اصل هزینه ی تراکنش انجام شده خواهد بود.
گیرنده ی هزینه ی پیراهن تا هنگامی که تراکنش تایید نشود نمی تواند بیت کوین دریافتی را هزینه کند.

2-10 مثال های عملی
در یک کبف پول دارای رابط کاربری گرافیکی بسیار انتقال بیت کوین راحت است اما الگوریتم پنهان در پشت آن را در ادامه در محیط ترمینال لینوکس برای فهم چگونگی انجام معاملات آورده ایم.
هدف از این بخش توضیح سرپایی نحوه ی ارسال یک تراکنش و معرفی دیداری جزییات یک تراکنش است برای آشنایی اولیه با کارکرد بیت کوین با استفاده از دستورات (دستور ها) موجود در بیت کوین کور .
دستور زیز که یک دستور json-rpc است یک ورودی txid می گیرد ،آن را در بلاکچین جستوجو می کند و جزییات آن را در اختیار می گذارد.
تراکنش زیر به تازگی انجام شده و هنوز تایید نشده ،یعنی قسمت confirmation هنوز صفر است.

$ bitcoin-cli gettransaction 9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3
{
"amount" : 0.05000000,
"confirmations" : 0,
"txid" : "9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3",
"time" : 1392660908,
"timereceived" : 1392660908,
"details" : [
{
"account" : "",
"address" : "1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL",
"category" : "receive",
"amount" : 0.05000000
}
]
}
اکنون می توان اطلاعات تراکنش را بعد از یک بار تایید مشاهده کرد.اطلاعات بلوکی که تراکنش در آن قرار دارد و زمان شروع تشکیل بلوک را که انکد شده مشاهده کرد
$ bitcoin-cli gettransaction 9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3
{
"amount" : 0.05000000,
"confirmations" : 1,
"blockhash" : "000000000000000051d2e759c63a26e247f185ecb7926ed7a6624bc31c2a717b",
"blockindex" : 18,
"blocktime" : 1392660808,
"txid" : "9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3",
"time" : 1392660908,
"timereceived" : 1392660908,
"details" : [
{
"account" : "",
"address" : "1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL",
"category" : "receive",
"amount" : 0.05000000
}
]
}
در صورت نیاز می توان کل اطلاعات یک بلوک را با استفاده از خروجی هش آن مشاهده کرد.
این بار نیز با استفاده از یک دستور، اطلاعات را از بیت کوین کور در خواست می کنیم. ورودی آن ،هش بلوکی است که در مرحله ی قبل در اطلاعات تراکنش جستوجو شده قرار داشت.
TX  ها تراکنش هایی هستند که داخل بلوک قرار گرفته و تایید شده اند.
HIGHT ارتفاع بلوک را نشان می دهد که یعنی قبل از این، به همین تعداد منهای یک بلوک وجود داشته.
در زیر تنها تعدادی از تراکنش ها نشان داده شده.
$ bitcoin-cli getblock 000000000000000051d2e759c63a26e247f185ecb7926ed7a6624bc31c2a717b true
{
"hash" : "000000000000000051d2e759c63a26e247f185ecb7926ed7a6624bc31c2a717b",
"confirmations" : 2,
"size" : 248758,
"height" : 286384,
"version" : 2,
"merkleroot" : "9891747e37903016c3b77c7a0ef10acf467c530de52d84735bd55538719f9916",
"tx" : [
"46e130ab3c67d31d2b2c7f8fbc1ca71604a72e6bc504c8a35f777286c6d89bf0",
"2d5625725b66d6c1da88b80b41e8c07dc5179ae2553361c96b14bcf1ce2c3868",
"923392fc41904894f32d7c127059bed27dbb3cfd550d87b9a2dc03824f249c80",
"f983739510a0f75837a82bfd9c96cd72090b15fa3928efb9cce95f6884203214",
"190e1b010d5a53161aa0733b953eb29ef1074070658aaa656f933ded1a177952",
"ee791ec8161440262f6e9144d5702f0057cef7e5767bc043879b7c2ff3ff5277",
"4c45449ff56582664abfadeb1907756d9bc90601d32387d9cfd4f1ef813b46be",
"3b031ed886c6d5220b3e3a28e3261727f3b4f0b29de5f93bc2de3e97938a8a53",
#[... many more transactions ...]
],
"time" : 1392660808,
"nonce" : 3888130470,
"bits" : "19015f53",
"difficulty" : 3129573174.52228737,
"chainwork" : "000000000000000000000000000000000000000000001931d1658fc04879e466",
"previousblockhash" : "0000000000000000177e61d5f6ba6b9450e0dade9f39c257b4d48b4941ac77e7",
"nextblockhash" : "0000000000000001239d2c3bf7f4c68a4ca673e434702a57da8fe0d829a92eb6"
}
در زیر نشان داده که می توان با استفاده از دستور ها و با دادن ارتفاع بلوک ، به هش بلوک دست پیدا کرد. در زیر هش GENESIS BLOCK یعنی اولین بلوک تولید شده را نشان می دهد.
$ bitcoin-cli getblockhash 0
000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f

2-11 چگونه یک کیف پول یک تراکنش انجام می دهد ؟
باید توجه کرد که اعمال زیر در حال انجام به صورت پله به پله برای فهم انجام یک تراکنش است و نیازی به انجام این اعمال در حالت عادی نیست و یک کیف پول ،خودکار این اعمال را انجام می دهد.
اگر در کیف پول ،یک ورودی که به طور مثال 50 میلی بیت ارزش داشته و می خواهیم 25 میلی بیت از آن را خرج کنیم، برای خرج کردن بایست کل آن را خرج کرد و به عنوان دو خروجی ان را شناخت که از یک ورودی ناشی شده و خرج کردن آن به این صورت است که 25 میلی بیت را به آدرس کیف پول مورد نظر می فرستیم و مابقی را به آدرس خودمان بر می گردانیم . این به علت آن است که یک ورودی در ساختار بیت کوین باید به طور کامل خرج شود و به چند خروجی تبدیل شود البته بایست که مقدار fee را از مقدار برگشتی به آدرس خودمان کم کنیم.
مثال:
1.	گرفتن خروجی هایی که از یک ورودی ناشی شده :
ورودی این دستور، txid تراکنش ورودی به کیف پول است و vout  آن که در حال حاضر صفر است زیرا که هیچ خروجی تا کنون از این ورودی ، انجام نشده (همانطور که گفته بودیم ورودی باید برای خرج شدن تبدیل به خروجی شود.)
$ bitcoin-cli gettxout 9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3 0
جواب:
{
"bestblock" : "0000000000000001405ce69bd4ceebcdfdb537749cebe89d371eb37e13899fd9",
"confirmations" : 7,
"value" : 0.05000000,
"scriptPubKey" : {
"asm" : "OP_DUP OP_HASH160 07bdb518fa2e6089fd810235cf1100c9c13d1fd2\
OP_EQUALVERIFY OP_CHECKSIG",
"hex" : "76a91407bdb518fa2e6089fd810235cf1100c9c13d1fd288ac",
"reqSigs" : 1,
"type" : "pubkeyhash",
"addresses" : [
"1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL"
]
},
"version" : 1,
"coinbase" : false
}
2.	ساخت تراکنش بادادن 25 میلی بیت به آدرس
1LnfTndy3qzXGN19Jwscj1T8LR3MVe3JDb
و بازگرداندن 24.5 میلی بیت به آدرس خودمان که در بالا مشاهده می کنیم.
یعنی 0.5 میلی بیت را به عنوان fee در نظر گرفته ایم.
$ bitcoin-cli createrawtransaction \
'[{"txid" : "9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3", "vout" : 0}]' \
'{"1LnfTndy3qzXGN19Jwscj1T8LR3MVe3JDb": 0.025, \
"1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL": 0.0245}'
دستور بالا یک تراکنش انکد شده ایجاد می کند که می توان آن را دیکد کرد.
جواب دستور بالا که رمز شده ی تراکنش است :
0100000001e34ac1e2baac09c366fce1c2245536bda8f7db0f6685862aecf53ebd69f9a89c\
0000000000ffffffff02a0252600000000001976a914d90d36e98f62968d2bc9bbd6810756\
4a156a9bcf88ac50622500000000001976a91407bdb518fa2e6089fd810235cf1100c9c13d\
1fd288ac00000000
میتوان دیکد شده ی آن را مشاهده کرد با اجرای دستور زیر:
$ bitcoin-cli decoderawtransaction \
0100000001e34ac1e2baac09c366fce1c2245536bda8f7db0f6685862aecf53ebd69f9a89c\0000000000ffffffff02a0252600000000001976a914d90d36e98f62968d2bc9bbd6810756\
4a156a9bcf88ac50622500000000001976a91407bdb518fa2e6089fd810235cf1100c9c13d\
1fd288ac00000000
جواب:
{
توضیحات ورودی
"txid" : "0793299cb26246a8d24e468ec285a9520a1c30fcb5b6125a102e3fc05d4f3cba",
"version" : 1,
"locktime" : 0,
"vin" : [
{
"txid" : "9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3",
"vout" : 0,
"scriptSig" : {
"asm" : "",
"hex" : ""
Scriptsig خالی است چون هنوز ارسال امضا نشده ، مرحله ی بعد امضای ارسال خواهد بود.
},
"sequence" : 4294967295
}
],
توضیحات خروجی اول که به آدرس جدید میفرستیم:
"vout" : [
{
"value" : 0.02500000,
"n" : 0,
"scriptPubKey" : {
"asm" : "OP_DUP OP_HASH160 d90d36e98f62968d2bc9bbd68107564a156a9bcf\
OP_EQUALVERIFY OP_CHECKSIG",
"hex" : "76a914d90d36e98f62968d2bc9bbd68107564a156a9bcf88ac",
"reqSigs" : 1,
"type" : "pubkeyhash",
"addresses" : [
"1LnfTndy3qzXGN19Jwscj1T8LR3MVe3JDb"
]
}
},
توضیحات خروجی دوم که به آدرس خودمان میفرستیم(یا بهتر است بگوییم بر می گردانیم):
{
"value" : 0.02450000,
"n" : 1,
"scriptPubKey" : {
"asm" : "OP_DUP OP_HASH160 07bdb518fa2e6089fd810235cf1100c9c13d1fd2\
OP_EQUALVERIFY OP_CHECKSIG",
"hex" : "76a91407bdb518fa2e6089fd810235cf1100c9c13d1fd288ac",
"reqSigs" : 1,
"type" : "pubkeyhash",
"addresses" : [
"1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL"
]
}
}
]
}
3.	امضای ارسال
انجام این کار یعنی تراکنشی که تشکیل داده ایم مورد تایید است
$ bitcoin-cli signrawtransaction 0100000001e34ac1e2baac09c366fce1c2245536bda8f7db0f6685862a\
ecf53ebd69f9a89c0000000000ffffffff02a0252600000000001976a914d90d36e98f62968d2bc9bbd68107564\
a156a9bcf88ac50622500000000001976a91407bdb518fa2e6089fd810235cf1100c9c13d1fd288ac00000000

اکنون اگر دوباره تراکنش را دیکد کنیم می بینیم قسمت scriptsig پر شده است.
خروجی دستور بالا یک عبارت انکد شده ی دیگر خواهد بود به صورت زیر که در مرحله ی بعد  به عنوان ورودی استفاده می شود.
4.	و در این مرحله یکtxid تشکیل خواهد شد که برای تایید( که توسط ماینر ها انجام میشود )، به بلاکچین فرستاده می شود . دستور زیر که ورودی آن همان عبارت انکد شده مرحله قبل است را میفرستیم.
$ bitcoin-cli sendrawtransaction\
0100000001e34ac1e2baac09c366fce1c2245536bda8f7db0f6685862aecf53ebd69f9a89c\
000000006a47304402203e8a16522da80cef66bacfbc0c800c6d52c4a26d1d86a54e0a1b76\
d661f020c9022010397f00149f2a8fb2bc5bca52f2d7a7f87e3897a273ef54b277e4af52051\
a06012103c9700559f690c4a9182faa8bed88ad8a0c563777ac1d3f00fd44ea6c71dc5127ff\
ffffff02a0252600000000001976a914d90d36e98f62968d2bc9bbd68107564a156a9bcf88a\
c50622500000000001976a91407bdb518fa2e6089fd810235cf1100c9c13d1fd288ac000000\
00
خروجی دستور بالا که همان txid مربوط به تراکنش است:
ae74538baa914f3799081ba78429d5d84f36a0127438e9f721dff584ac17b346





فصل سوم
آدرس ها و کلید ها و کیف پول




برای انجام عملیات ارسال و پرداخت نیاز به آدرس هایی داریم که توسط کیف پول تولید شده است .
برای امنیت تولید این آدرس ها چند نوع رمزنگاری استفاده شده که به آنها می پردازیم.
کلید خصوصی :
کلیدی که تنها در اختیار کیف پول قرار دارد و کلید عمومی با رمز نگاری از روی آن تولید می شود . البته رمز نگاری به گونه ای هست که قابل بازگشت نباشد و تنها کسی بتواند کلید عمومی را بازسازی کند که کلید خصوصی را داشته باشد.
از خصوصیت برگشت ناپذیری برای امضای تراکنش استفاده می شود.
بر روی bitcoind   که قبلا اشاره شد قسمتی از بیت کوین کور است، دستور هایی برای تولید کلید جدید وجود دارد:
برای تولید آدرس:
$ bitcoind getnewaddress
جواب:
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
و برای گرفتن کلید خصوصی از دستور زیر که ورودی آن آدرس است استفاده می شود.
$ bitcoind dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
جواب:
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ

البته نباید موجب به تشویش ذهن شود. قبلا گفتیم که کلید عمومی و آدرس از روی کلید خصوصی ساخته می شود این عملیاتی یک طرفه است و ممکن است بگویید چرا اکنون باید کلید عمومی را به یک دستور بدهیم تا کلید خصوصی را به ما بدهد .
جواب این است که کلید خصوصی چیزی است که مالکیت پول را برای شما محفوظ میدارد و وظیفه ی کیف پول است که آن را ذخیره کند . حال اکر هم کلید عمومی و هم کلید خصوصی را ذخیره داشته باشیم ودر کنار یکدیگر قرار دهیم ، می توانیم بفهمیم که کدام کلید خصوصی بوده که توسط آن کلید عمومی تولید شده.
و باید یادآور شد که کیف پول ها الزاما نباید کلید عمومی را ذخیره کنند و تنها وظیفه ی آن ها ذخیره ی کلید خصوصی است .
کاربر کیف پول با همان مالک ارز دیجیتال باید از روی کلید های خصوصی خود نسخه ی پشتیبانی تهیه کند تا مبادا اموال خود را از دست  بدهد.
3-1 چگونه کلید خصوصی تولید کنیم؟
کلید خصوصی به صورت رندم به دست می آید. البته با در نظر گرفتن امنیت تولید آن . مانند استفاده نکردن از ژنراتور عدد رندم CPU به علت قابل پیش بینی بودن آن .
پیش نهاد می شود این عدد رندم با روش CSPRG تولید شود .
بعد از تولید عدد رندم باید آن را از هش SHA256  که یک خروجی 256 بیتی یا 64 بایتی خواهد داشت گذر داد . در صورت اینکه این عدد بین 1 و N-1 بود که N برابر است با 1.158 * 10^77 ، آنگاه ی کلید خصوصی تولید کرده اید .
3-2 تولید کلید عمومی از خصوصی
در ابتدا باید با رمزنگاری SECP256K1 آشنا شویم.
مخفف SPECIFIC ELLIPTIC CURVE با تابع :
y 2 = (x 3 + 7)
و با رسم :
 
شکل 3-1 تابع مخصوص رمزنگاری SECP256K1
ولی نه تمام نقاط منحنی . به این معنا که نقاط انتخابی بر روی آن پیوسته نیستند و باید شرط زیر را اغنا کنند :
Y^ 2 mod p = (x^ 3 + 7) mod p
Mod عملیات گرفتن باقی مانده است و p عددی اول با مقدار :
p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1
اگر k  کلید خصوصی باشد و K کلید عمومی ، داریم :
K = k *G
که  G عددی ثابت است که همه مقدار آن را می دانند و عملیات * به معنای انجام پیدا کردن نقطه ی بی نهایت بر روی منحنی بالا به تعداد G بار پشت سر هم است .
پیدا کردن نقطه بی نهایت به این صورت است: ابتدا نصفه ی اولی(پرارزش) k را به عنوان x و نصفه ی دوم را به عنوان y سپس یک نقطه را طبق آن بر روی منحنی بر می داریم و یک خط بر روی منحنی در آن نقطه مماس می کنیم تا نقطه ی دیگری را قطع کند . نقطه ی قطع شده را نسبت به محور x تقارن میدهیم . و دوباره این عملیات را به تعداد G  بار انجام می دهیم.
مانند شکل زیر :
 
شکل 3-2 انجام G بار پیدا کردن نقطه مماس(بی نهایت)
برای دریافت بیت کوین باید یک آدرس در اختیار پرداخت کنند قرار بدهیم که آن را با انجام عملیاتی از روی کلید عمومی به دست خواهیم آورد.
به صورت زیر
A = RIPEMD160(SHA256(K))
که RIPEMD160 نیز یک الگوریتم هش با 160 بیت یا 20 بایت خروجی است.
بعد از عملیات بالا یک 0x00 به خروجی به عنوان پیشوند اضافه می شود(به عنوان نسخه (چون اطلاعات زیادی هستند در عملیات های بیت کوین که با base58 انکد میشوند )) و سپس به  base58check  انکد می شود بعد از آن یک عدد 1 به عنوان پیشوند به آن اضافه می شود .
 
شکل 3-3 محاسبه ی آدرس کیف پول
3-3base58 
Base به معنای مبنا ، نحوه ی نشان دادن اعداد به زبان کامپیوتری را تغییر می دهد و کلا هدف از آن کوتاهتر نشان دادن اعداد بسیار طولانی و راحت تر خوانده شدت آن اعداد توسط انسان است.
اگر یک عملیات checksum به روشی که بعدا خواهم گفت روی base58 اعمال شود تبدیل به انکدینگ base58check می شود.
با مبنای 16 آشنایی داریم و باید بدانیم کامپیوتر اگر بخواهد با مبنای 64 اعداد را نشان دهد باید از اعداد و حروف بزرگ و کوچک انگلیسی و تعدادی از نماد ها استفاده کند .
Base58 نیز همین گونه است اما تعدادی از اعداد و حروف و نمادهایی که منجر به خطا در خواندن می شود را حذف کرده است (هدف کلا تولید عددی برای راحت تر خوانده شدن انسان و جلو گیری از خطا بود ) از جمله :
0 (number zero), O (capital o), l (lower L), I (capital i)
و نماد های :
\    و +  و  /
به طور کلی الفبای base58 :
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
4-3base58check 
برای تولید این انکدینگ ابتدا به payload (اطلاعاتی که می خواهیم انکد کنیم) پیشوند نسخه را اضافه می کنیم (که برای آدرس 0x00 بود)  سپس اطلاعات به دست آمده را دوبار از sha256 رد می کنیم.
4 بایت ابتدایی تولید شده را به عنوان checksum به عنوان پسوند به اطلاعات قبلی اضافه می کنیم. سپس با base58 انکد می کنیم.
اضافه کردن checksum برای جلوگیری از ایجاد خطا هنگام ارسال و دریافت بیت کوین در هنگام نوشتن آدرس انجام می شود.
فرض کنید یک آدرس را برای ارسال بیت کوین انتخاب می کنید . کیف پول اطلاعات را از base58 دیکد می کند و با گذر از sha256 مطمئن می شود که آدرسی که در حال ارسال بیت کوین به آن هستید valid خواهد بود یا نه.
اکنون base58check داریم . برای ساختار bitcoin باید یک پیشوند برای اطلاع پیدا کردن از نوع اطلاعات بعد از تولید base58check به آن اضافه کنیم. که برا آدرس، عدد 1 خواهد بود . درجدولی این پیشوند ها که قبل و بعد از تولید base58check باید به آن اضافه شوند خواهد آمد .

Base58_result_prefix	Version prefix	Type
1	0x00	Bitcoin address
3	0x05	Pay-to-Script-Hash Address
m or n	0x6f	Bitcoin Testnet Address
5 or K or L	0x8f	Private Key WIF
6P	0x0142	BIP38 Encrypted Private Key
xpub	0x0488B21E	BIP32 Extended Public Key
جدول 3-1 پیشوند های قبل و بعد از تشکیل انواع اطلاعات انکد شده به base58check
در جدول بالا باید به بزرگی و کوچکی حروف  Base58_result_prefix  دقت شود . به علت وجود حروف بزرگ و کوچک در انکدینگ base58 .
تصویر زیر عملیات تولید BASE58CHEK را به صورت تصویری نشان می دهد .
در جدول بالا چند لغت ناشناخته مانند WIF و testnet  و BIP وجود دارد که بعدا در باره ی آن ها توضیح خواهیم داد.
 
شکل 3-4 تولید base58check
5-3Key Formats 
1-5-3Private Key Formats
کلید های خصوصی را با 3 فرم مختلف ذخیره می کنند .
1.	Hex : 64 hexadecimal digits
قبلا هم گفته بودیم که کلید خصوصی 256 بیتی تولید شده توسط sha256 است که در نتیجه 64 دیجیت از نوع هگزادسیمال خواهد بود.
2.	WIF:
روش تولید این فرم همان base58check  است با نسخه 128 و  پیشوند 5 بعد از تولید base58check
3.	WIF-compressed:
اگر پسوند(توجه کنید پسوند به معنای اضافه شدن به عنوان بایت کم ارزش) ox01 به فرم هگزا دسیمال اضافه کنیم سپس عملیات WIF را که در بالا توضیح داده شد را روی آن انجام دهیم ، این فرمت ایجاد می شود. منتها برای نشان گذاری به جای اضافه کردن 5 به عنوان پیشوند K یا L( توجه به بزرگی حروف) اضافه می شود.
یادآوری می کنم تمام فرم های بالا همه کلید خصوصی هستند منتها به فرم های مختلف.
2-5-3 Public Key Formats
قبلا گفته شد که کلید عمومی از روی کلید خصوصی و با روش elliptic curve به دست می آید.
خروجی یک مختصات دو بعدی با یک x  و y که هر کدام 256 بیت هستند. اگر فرم
04 x y را تشکیل دهیم ، یعنی پسوند 04 و قرار دادن x در مکان پر ارزش و y در کم ارزش، 520 بیت خواهیم داشت که فرم هگزا دسیمال غیر فشرده ی کلید عمومی خواهد بود .
همانطور که گفتیم x , y از تابع دو بعدی و توسط رمزنگاری secp256k1 تولید می شوند که تابع، منحنی خاصی را ارضاء می کنند .
اگر به رسم تابع و نحوه ی تولید کلید عمومی برگردیم ، y می توانست که هم منفی و هم مثبت باشد اگر عملیات بیتی روی y انجام گیرد با توجه  به منفی یا مثبت بودن ،عددی فرد یا زوج از روی y ساخته می شود . این موضوع را هم می دانیم که با توجه به داشتن
1.	تابع منحنی و
2.	داشتنx و
3.	اینکه y مثبت است و یا منفی
می توان از روی x به y دست پیدا کرد .
پس می توان 50 درصد از فضا را صرفه جویی کرد و تنها به وسیله ی x و اینکه y فرد است یا زوج (مثبت است یا منفی) ،کلید عمومی را روی بلاکچین منتشر کرد تا بلاکچین فضای کمتری را اشغال کند. این فرم کلید عموم را فشرده شده می نامند.
04 پیشوند حالت غیر فشرده ی کلید عمومی را داشت . 02 پیشوند x خواهد بود وقتی y زوج باشد و 03 خواهد بود اگر y فرد باشد.
تصویر زیر فشرده سازی کلید عمومی را نشان می دهد .
 
شکل 3-5 تشکیل compressed public key
اینجا یک مشکل وجود دارد .
از روی کلید عمومی، آدرس ساخته میشد . ناکاماتو بعدها تصمیمی بر این گرفت که فرم فشرده ی کلید عمومی را استفاده کند و این باعث شد که گره های آپدیت نشده هنوز از فرم پیشین استفاده کنند . اگر چه که ناکاماتو با روش soft fork  همیشه قصد داشته آپدیت ها را تحمیل کند .(بعدها در مورد soft fork توضیح داده خواهد شد)
پس دو آدرس متفاوت از روی یک کلید عمومی به دست خواهد آمد که موجب به این می شود که سازوکاری برای کیف پول هایی که از این دو روش استفاده می کنند تعیین شود.
6-3  رفع یک شبهه
شاید با خود بگویید ما از فشرده سازی کلید عمومی گفتیم ولی از فشرده سازی کلید خصوصی چیزی نگفتیم در عین حال یکی از فرم های ذخیره سازی کلید خصوصی ، WIF و دیگری WIF_compressed بود که شاید این شبهه پیش بیاید که چرا compressed  ؟
این کلمه فقط برای این گذاشته شده که بگوید کیف پول های قدیمی از wif استفاده می کند و wif برای تولید  کلید عمومی غیر فشرده استفاده میشود وکیف پول های جدید از نوع compressed_wif  برای این کار استفاده می کنند و روش فشرده سازی کلید عمومی را استفاده می کنند . این کلمه مربوط به نحوه ی انتشار کلید عمومی اشاره می کند با اینکه در نام کلید خصوصی می آید.
اگر به قبل برگردیم و نوع wif_compressed  را نگاه کنیم، می بینیم اگر آن را از base58 دیکد کنیم یک بایت( 0x01)  اضافه تر داشت و این به کاربر کیف پول می فهماند که کیف پول در حال استفاده از کدام نوع کلید عمومی است .
7-3 انواع کیف پول
کیف پول ها را از لحاظ نحوه ی تولید کلید خصوصی به دو دسته تقسیم می کنند .
1.	آنهایی که هر کلید خصوصی را به صورت رندم تولید می کنند . که به یکدیگر هیچ ربطی ندارند و از روی یکدیگر تولید نمیشوند.
2.	آنهایی که یک هسته دارند و از روی آن هسته (البته به علاوه ی موارد دیگر که بعدا به آن می پردازیم)،اولین کلید خصوصی تولید می شود و کلید خصوصی بعدی از روی کلید قبلی و با انجام عملیات هش تولید می شود و این موضوع تا انتها ادامه دارد.
بیت کوین کور دارای کیف پولی از نوع اول است با این که خود توسعه دهندگان بیت کوین کور معتقدند این نوع کیف پول ضعیف می باشد . به این نوع کیف پول می گویند
Type-0 Non-Deterministic و دارای اسم مستعار “Just a Bunch Of Keys” است که مخفف آن   JBOKخواهد بود.
کیف پول از نوع اول دارای سه مشکل اساسی است .
اول اینکه ارسال بیت کوین، با خطر address reuse مواجه است .  address reuse  یکی از عوامل به خطر افتادن privacy  است. به این معنا که افراد دیگر ممکن است از دارایی شما با خبر شوند . این خطر که ترجمه  آن چندبار استفاده از آدرس است ، به این دلیل خطرناک است که آدرس ها در بلاکچین ذخیره می شوند و قابل پیگیری هستند. با توجه به اینکه فردی که برای شما بیت کوین میفرستد شما را میشناسد و آدرس شما را در اختیار دارد می تواند در بلاکچین به دنبال همین آدرس بگردد و تمام پرداخت هایی که با این آدرس به شما انجام گرفته است را دنبال کند.(اگر به مثال های قسمت های اول برگردیم که با یک دستور ، اطلاعات یک بلوک را دریافت کردیم به این موضوع پی میبرید)
برای اطلاعات بیشتر و مثال های به خطر افتادن privacy ، به آدرس bitcoin.it/privacy  مراجعه کنید.
و دوم اینکه برای جلوگیری از دست دادن دارایی ،مجبور هستیم از روی اطلاعات کیف پول با هر بار تولید آدرس جدید، نسخه ی پشتیبان تهیه کنیم تا هیچکدام از کلید های خصوصی را از دست ندهیم .
و سوم اینکه اطلاعات کیف پول در طول زمان زیاد و زیاد تر میشود.
اما در صورت استفاده از کیف پول نوع دوم برای جلوگیری از دست دادن دارایی تنها نیاز هست در همان ابتدا یک نسخه ی پشتیبان بگیریم تا هسته ی اولیه را ذخیره کرد . مابقی آدرس ها از روی هسته قابل تشکیل هستند .
با این تدبیر ،حافظه ی کمتری برای کیف پول خواهیم داشت .
البته استفاده از این نوع کیف پول ها از این لحاظ که بر روی هیچ سروری نیاز نیست تا ثبت شوند ، امنیت بالاتری خواهند داشت.
به نوع دوم کیف پول Deterministic (Seeded) Wallets هم می گویند .
از انواع کیف پول نوع دوم میتوان از HD_wallet  نام برد یا Hierarchical Deterministic Wallets .
 
شکل 3-6 کیف پول HD
با توجه به شکل بالا در کیف پول HD ، یک کلید خصوصی در مرحله ی قبل، یک سکانس از کلید های خصوصی می تواند بسازد.
نحوه ی تولید seed یا هسته می تواند به صورت Mnemonic Code Words باشد .
BIP39 نحوه تولید Mnemonic Code Words را به صورت زیر بیان می کند .
1.	یک عدد رندم با سایز 128  تا 256 بیت
2.	ساخت یک checksum  به وسیله ی هش sha256 و برداشتن تعدادی از بیت های اولیه خروجی
3.	خروجی مرحله ی قبل را به بیت های 11 تایی تقسیم می کنیم و با توجه به اینکه به هر 2048 کد یک کلمه ی خاص اختصاص داده ایم ، به تعدادی کلمه در کنار هم میرسیم.
بعد از انجام مراحل بالا با یک الگوریتم خاص آن را به یک اطلاعات 512 بیتی تبدیل می کنیم.
در تصویر زیر ent عدد رندم است و cs همان checksum است.
 
شکل 3-7 نحوه ی تشکیل کد mnemonic
8-3 روش تولید کلید خصوصی از روی هسته
بعد از تولید کد بالا باید اولین کلید خصوصی از روی آن تولید شود. آن را از sha512 رد می کنیم. خروجی آن را دو قسمت می کنیم .
قسمت  پر ارزش تر به عنوان کلید خصوصی خواهد بود و نصفه ی کم ارزش تر به عنوان master chain code  شناخته میشود.
Chain code ها به عنوان هسته برای ساخت کلید خصوصی بعدی استفاده می شود.
 
شکل 3-8  تشکیل اولین کلید ها و chain code از روی هسته
عکس بالا نشان می دهد بعد از تولید کلید خصوصی یک کلید عمومی از روی آن تولید می شود .
کد mnemonic برای بازیابی کیف پول در دست صاحب کیف پول ذخیره خواهد شد.
اکنون که اولین کلید تولید شد نیاز داریم کلید های بعدی را از روی همین کلید عمومی تولید شده ایجاد کنیم منتها این بار با استفاده از سه دسته اطلاعات :
1.	Index
2.	Public key
3.	Chain code
Index   اطلاعاتی 32 بیتی است که کمک می کند چندین کلید از روی یک کلید عمومی به همراه chain code و کلید خصوصی قبلی تولید بشود . تنها کلید اولیه(master) است که index  ندارد.
شکل زیر نحوه ی تولید را نشان می دهد . که کلید خصوصی جدید از محاسبه ی هش و کلید خصوصی قبلی به دست می آید و تفاوت آن در index  است.
 
شکل 3-9 تشکیل کلید های بعدی از اولین کلید و chain code قبلی

برتری کیف پول HD نسبت به کیف پول نوع اول :
1. همانطور که دیدید می توان از روی کلید عمومی یک کلید خصوصی جدید ساخت و این امنیت را بالا می برد .
2. قبلا اشاره کردیم که برای ارسال بیت کوین ، تمام یک ورودی باید به خروجی تبدیل شود ؛ در اوایل گفتیم برای آن قسمتی که می خواهیم به خودمان برگردد ، آدرس خودمان را وارد می کنیم تا قسمتی از پول که خرج نکرده ایم به خودمان برگردد.
برای این کار از همان آدرس ورودی خود استفاده کردیم . می توان برای افزایش privacy از یکی دیگر از آدرس هایی که در بالا در یک شاخه ی دیگر قرار داشته استفاده کنیم.
به مجموعه ی  یکی از کلید ها(خصوصی یا عمومی) همراه با chain code  ، extended key  می گویند که ویژگی های خاصی دارند .مثلا public extended key را می توان به base58 انکد کرد و بین کیف پول های مختلف رد و بدل کرد (البته کیف پول هایی که الگوریتم یکسان داشته باشند و متعلق به یک شخص باشند)
Private extended code برای امضای تراکنش ها استفاده می شود و بدون آن تایید تراکنش ممکن نیست.
به این علت که public extend code  در دسترس همه هست که به این معناست که در صورت دسترسی فردی به کلید خصوصی قبلی می تواند به هزاران کلید خصوصی دیگر از آن کیف پول دسترسی پیدا کند .
برای همین روش دیگری نیز وجود دارد که به آن Hardened child key می گویند که اثر کلید عمومی در تولید کلید خصوصی جدید را حذف می کند.

 
شکل 3-10 تشکیل کلید های بعدی از روی کلید خصوصی برای امنیت بیشتر
9-3Encrypted Private Keys (BIP0038) 
هنگامی که از کلید خصوصی پشتیبان تهیه می کنید و در جایی مانند فلش دیسک ذخیره می کنید ،ممکن است آن را گم کنید یا آن را از شما بدزدند برای جلوگیری از این خطر بایست آن را با استفاده از یک رمز تقویت کنید.
برای این کار می توانید به سایت bitaddress.org  مراجعه کنید .
یک کلید خصوصی رمز نشده با فرمت wif (که قبلا اشاره شده ) دارای پیشوند 5 هستند و در فرمت base58   انکد شده اند . اگر کلید خصوصی رمز شده باشد دارای پیشوند 6P خواهد بود.

10-3Pay To Script Hash (P2SH) 
در بانک ها حساب هایی هستند که برای تصمیم گیری در مورد اموال ذخیره شده در آن بایست چند نفر تصمیم بگیرند و آن ها با امضای به عنوان مثال یک چک اجازه می دهند یک تراکنش انجام بگیرد.
ممکن است یک کیف پول متعلق به یک شرکت باشد و آن شرکت نیاز به یک حساب اشتراکی داشته . با توجه به BIP16 یک راه ، pay to script address است که همانند آدرس معمولی حتی تولید می شود ولی برای اعمال پرداخت نیاز به امضای چند کاربر خواهد بود.
script hash = RIPEMD160(SHA256(script))
منتها ورودی آن به جای کلید عمومی ، script  خواهد بود.
Script hash انکد شده در base58 و نشانه ی آن (پیشوند آن) 3  خواهد بود.

11-3Vanity Addresses 
به آدرس زیر توجه کنید :
1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33
1 پیشوند ی است به نشانه ی آدرس بودن آن و در ادامه کلمه ی Love وجود دارد .
برای تولید چنین آدرسی بایست چندین بار ورودی رندم به تولید کننده ی کلید خصوصی بدهیم تا چنین آدرسی را به ما تحویل دهد . پس نیاز به قدرت محاسباتی بالا دارد  رسیدن به آن زمان بر است.
حتی می توان برای تولید چنین آدرس هایی ، آدرس دلخواه خود را به vanity-miners   تا برای ما یک کلید خصوصی با چنین خصوصیتی تولید کنند .
این کار شمشیر دو لبه است . اگر مشتریان خاصی داشته باشید ، مشتریان می دانند که شما آدرسی دارید با یک چنین ویژگی و اگر کلمه ی  Love   را ببیند میفهمند که این آدرس متعلق به شماست .
فرض کنید این آدرس را بر روی سایت خود قرار داده اید . فردی می تواند سایت شما را هک کند و قبلا یک آدرس که همانند شما با Love  شروع می شود تولید کرده باشد و آن آدرس را جایگذاری کند و در نتیجه دارایی که قرار بود متعلق به شما باشد را بدزدد.
جدول زیر را نگاه کنید :

1	1K	1 in 58 keys	< 1 milliseconds
2	1Ki	1 in 3,364	50 milliseconds
3	1Kid	1 in 195,000	< 2 seconds
4	1Kids	1 in 11 million	1 minute
5	1KidsC	1 in 656 million	1 hour
6	1KidsCh	1 in 38 billion	2 days
7	1KidsCha	1 in 2.2 trillion	3-4 months
8	1KidsChar	1 in 128 trillion	13-18 years
9	1KidsChari	1 in 7 quadrillion	800 years
10	1KidsCharit	1 in 400 quadrillion	46,000 years
جدول 3-2 مثال برای زمان تشکیل یک vanity address
از بالا به پایین در سمت چپ ابتدا ردیف و سپس کلمات ابتدایی که می خواهیم آدرس ما آن را داشته باشد و سپس تعداد تلاش ها برای تولید چنین آدرسی و سپس زمان تولید آن با یک کامپیوتر معمولی را نشان می دهد.
اگر بیش از 7 حرف را تمایل داشته باشید با کامپیوتر های معمولی امکان پذیر نخواهد بود.
فرض کنید شما 6 کلمه ی اول را تشکیل داده باشید و مشتریان برای اطمینان از آدرس شما دو کلمه ی بعد را هم چک کنند ، فردی دیگر نخواهد توانست با تشکیل آدرسی که 6 حرف اولش با شما یکی است پول شما را بدزدد زیرا برای این کار باید دو حرف بعد از آن را نیز تولید کند که امکان پذیر نخواهد بود.

3-12Paper Wallets 
ممکن است نخواهید نسخه ی پشتیبان خود را بر روی یک فلش دیسک نگه دارید و بخواهید آن را به صورت چاپ شده داشته باشید و در یک گاو صندوق نگهداری کنید .
Paper wallet  ها همان چیزی هستند که می خواهید . شامل کلید خصوصی و یک آدرس اند که دارایی خود را ابتدا به آن آدرس میفرستید سپس در صندوق امانات بانک و یا گاو صندوق نگهداری می کنید .
برای امنیت بیشتر(ممکن است فردی از آن عکس تهیه کند ) ، کلید خصوصی آن را می توانید رمز شده (bip38 ) چاپ کنید و رمز آن را به خاطر بسپارید .
حتی می توان به عنوان هدیه paper wallet  ها را به دوستان خود اهدا کنید .
 
شکل 3-11 یک paper wallet













فصل چهارم
تراکنش ها  




تمام آن چیزی که در بیت کوین پیش بینی شده برای انجام یک تراکنش بیت کوینی است.
از همان زمان که یک کیف پول ایجاد می شود و به یک گره فرستاده می شد تا آنجا که توسط یک ماینر تایید می شود و در نهایت به بلاکچین اضافه می شود.
فردی تصمیم می گیرد مقداری بیت کوین بفرستد .برای این کار یک تراکنش تشکیل می دهد که با یک رمز قفل شده و تنها گیرنده است که آنرا برای تراکنشی که می خواهد انجام دهد رمز گشایی می کند که در نتیجه آن بیت کوین را مصرف می کند .
بعد از ایجاد یک تراکنش باید آن را به گره های مختلف فرستاد تا آن ها تراکنش را بین تمام گره ها پخش کنند ، از یک گره به چند گره دیگر تا جایی که تمام گره ها اطلاعات را دریافت کند.
اولین گره هایی که تراکنش را دریافت می کنند آن ها را تایید می کنند و اگر تراکنش ها صحیح باشند به گره های بعدی فرستاده می شود و گرنه یک پیام خطا به فرستنده اعلام می شود. هر گره وظیفه دارد اطلاعات دریافتی را کنترل و تایید کند .

هنگامی که تراکنش ها به تعداد بار معینی تایید شوند (confirmation)  و در بلوک ها قرار بگیرند (تعداد را در bitcoin.it  شش بار اعلام کرده یعنی زمان تقریبی 1 ساعت ) آنگاه هست که دریافت کننده ی بیت کوین می تواند آن را خرج کند .
یک تراکنش بین 300 تا 400 کیلو بایت اطلاعات دارد که باید بین تمام گره ها تقسیم شود .
فرستنده ها نیازی ندارند که به گره ها اعتماد داشته باشند مبادا در اطلاعات تراکنش آن ها خدشه ای وارد کنند تا زمانی که اطلاعات را به چندین گره بفرستند .
و گره ها نیازی نیست تا از حقیقی بودن گیرنده اطلاع پیدا کنند و به آن اعتماد کنند زیرا اطلاعات دریافتی امضا شده و هیچگونه اطلاعات محرمانه ندارد.
1-4 ساختار یک تراکنش
1.	نسخه : نسخه ی تراکنشی که در حال حاضر شبکه از آن استفاده می کند . 4 بایت اطلاعات
2.	شمارنده ی ورودی : تعداد ورودی هایی که در یک تراکنش استفاده شده اند . 1 تا 9 بایت
3.	ورودی ها : یک یا چند ورودی استفاده شده . حافظه ی مورد نیاز متغیر است.
4.	شمارنده ی خروجی: تعداد خروجی ها استفاده شده . 1 تا 9 بایت اطلاعات
5.	خروجی ها : یک یا چند خروجی تراکنش . حافظه ی متغیر
6.	Unix_time  :lock_time   یا شماره بلوک 4 بایت

توضیحات 6 :lock time زمانی هست که تمایل داریم تراکنش در آن زمان انجام شود . بیشتر وقت ها این قسمت 0 قرار داده می شود به معنای آنی بودن تراکنش.
اگر این عدد بالاتر از 500 ملیون باشد گوینده ی زمان مورد نظر برای اعمال تراکنش است به فرمت unix  و اگر بین 0 و 500 ملیون باشد گوینده ی شماره ی بلوکی است که در هنگام تشکیل آن می خواهیم تراکنش اعمال شود.

2-4UTXO   
هنگامی که فردی بیت کوین دریافت می کند ، آن به عنوان یک UTXO در بلاکچین ذخیره می شود که مالکیت آن توسط فردی که کلید خصوصی را دارد lock شده .
بلاکچین وظیفه ندارد به مالک بگوید چه مقدار دارایی دارد بلکه این کیف پول است که با توجه به اطلاعات ذخیره شده در خود(به عنوان مثال کلید خصوصی که از روی آن به آدرس دست پیدا می کند ) ، دارایی های فرد را از روی بلاکچین scan  می کند.
پس هیچ حسابی بر روی بلاکچین وجود ندارد بلکه فقط تعدادی UTXO است که مالکیت آن ها را کسی نمی داند . تنها کیف پول است که می داند آن  UTXO متعلق به کیف پول است یا خیر.

3-4 نحوه ی پرداخت
قبلا گفته بودیم که خروجی ها باید کامل خرج شوند و اگر از یک خروجی بخواهیم مقدار کمتری از بیت کوینی که در آن خروجی قرار دارد باید مقدار دلخواه را به گیرنده ی بیت کوین و مابقی را به آدرسی از کیف پول خود بفرستیم.
و یا اگر مقدار دلخواه برای ارسال بیشتر از مقدار بیت کوین موجود در یک خروجی باشد، باید به تعداد مناسب خروجی را جمع کنیم تا به مقدار مورد نظر برای پرداخت برسیم.
البته این اعمال به طور اتوماتیک توسط کیف پول انجام می شود.
مثال:
می خواهیم 50000000  ساتوشی خرج کنیم و سه خروجی با مقدار های 2500000 و 16100000 و 16050000 داریم .
از تراکنش آخر 7150000  ساتوشی باقی می ماند که به آدرس خود بر می گردانیم.

4-4Coinbase transaction 
به اولین آدرسی که داخل یک بلوک قرار می گیرد (بعدا بیشتر در باره ی تشکیل بلوک ها و عملیات تایید توضیح داده خواهد شد) coinbase addrss می گویند که هیچ خروجی نخواهد داشت (از هیچ کجا به این آدرس پرداخت صورت نمی گیرد بلکه خود بلاکچین است که مقداری به این آدرس بیت کوین میفرستد)
شاید اول بپرسید ابتدا خروجی تشکیل می شود یا ورودی . به این علت که coinbase transaction  هیچ خروجی ندارد و تنها ورودی دارد ، ابتدا ورودی است که تشکیل می شود (یعنی آدرسی که تشکیل می شود تا شما به آن بیت کوین پرداخت کنید ابتدا تشکیل می شود. شاید بدیهی به نظر برسد ولی توجه به آن بدون ضرر نیست.)
ارسال بیت کوین یعنی قبلا یک UTXO که وابسته به یک آدرس (آدرس در قسمت locking script موجود است) بوده در بلاکچین حضور دارد و خرج کردن آن UTXO برای صاحب آدرس با قرار دادن امضا در کنار locking script امکانپذیر خواهد شد.

5-4 ساختار UTXO
1.	مقدار به واحد ساتوشی : 8 بایت
2.	سایز locking_script: 1 تا 9 بایت
3.	locking_script: سایز متغیر
locking_script : قسمتی که خروجی را قفل می کند و شرایط را برای باز کردن قفل و خرج کردن آن بیان می کند.
نام دیگر آن Encumbrance می باشد.

6-4 ورودی تراکنش
تصور کنید شما مقداری بیت کوین دریافت کرده اید ؛ در هنگام دریافت، کیف پول شما به عنوان یک output شناخته میشد . اکنون شما می خواهید مقداری بیت کوین خرج کنید که کیف پول شما به عنوان یک ورودی از طرف فردی که می خواهید به او بیت کوین بفرستید شناخته خواهد شد.
در حقیقت ورودی، یک اشاره گر است به یک خروجی . که خروجی در کیف پول فرد مقابل قرار دارد.

7-4 ساختار تراکنش

یک ورودی شامل چند UTXO می تواند باشد .(در صورت بزرگتر بودن یک ورودی از UTXO های کیف پول )
برای خرج کردن یک UTXO باید شرایط locking_script  آن را ارضا کرد. برای همین به تعداد UTXO های موجود در یک ورودی ،باید  unlocking_script جود داشته باشد تا نشان دهد که می توان آن UTXO ها را خرج کرد .
برای تشکیل یک UTXO جدید(در یک کیف پول جدید متعلق به فردی دیگر ) نیاز به چند input ممکن است داشته که همان UTXO های قدیمی(در کیف پول خودمان) هستند .
ساختار هر input به شکل زیر است :

1.	transaction hash   : هش تراکنش ، اشاره گر به UTXO قدیمی که باید خرج شود و 32 بایت حافظه نیاز است.
2.	شماره ی ردیف UTXO ای که باید خرج شود (index) حاوی 4 بایت اطلاعات
3.	طول unlocking _script : بین 1 تا 9 بایت
4.	unlocking _script : قسمتی که باید  حاوی شرایط قسمت locking_script مربوط به UTXO  ی قدیمی باشد . که حاوی امضایی است مبنی بر تایید پرداخت و یا بهتر بگوییم باز کردن قفل UTXO
5.	sequence number: در حال حاظر این قسمت در ساختار بیت کوین نادیده گرفته می شود و غیر فعال است . مقدار آن را بیشترین مقدار ممکن یعنی 0xFFFFFF( که می شود 4 بایت حافظه ی مختص این قسمت )می گذارند.
اگر یادتان باشد یک تراکنش قسمتی به نام lock_time داشت که زمان اعمال تراکنش را اعمال می کرد.این عدد، برای لغو کردن انجام تراکنش، قبل از رسیدن زمان lock_time  استفاده می شود.
اگر حداقل یکی از  ورودی ها دارای مقدار sequence number کمتر از 0xFFFFFF باشد و در عین حال lock_time  مقداری غیر صفر داشته باشد آنگاه این ویژگی فعال خواهد شد .
ولی در عین حال غیر فعال و غیر قابل استفاده است.

8-4Bitcoin fee 
افرادی دارند تراکنش های شما را تایید می کنند و برای این کار انرژی صرف می کنند . شما باید بهای مصرف انرژی آن ها را بدهید یا حداقل آنها را ترغیب کنید تا تراکنش شما را تایید کنند (منظور ماینر ها هستند ).
در ساختار بیت کوین برای این کار bitcoin fee مطرح می شود .
fee مقداری از ارزش تراکنش شما است که به ماینر ها می دهید.
در ابتدا برای هر تراکنش ، مقدار ثابتی fee قرارداد شده بود ولی اکنون مقدار آن توسط حافظه ای که تراکنش شما اشغال می کند fee تعیین می شود .
به ازای هر کیلوبایت 0.0001  بیت کوین . اگر یادتان باشد ساختار یک تراکنش شامل ورودی ها و خروجی ها بود . اگر تعداد آن ها کم باشد حتی حافظه ی اشغالی از یک کیلوبایت هم بیشتر نمی شود .
لازم است بگوییم دادن قسمتی از ارزش تراکنش به هیج عنوان ضروری نیست.
البته این یک شمشیر دو لبه است . در صورت ندادن fee ماینر ها ترغیب نمی شوند تراکنش شما را تایید کنند مگر در موارد خاص .(که بعدا توضیح داده خواهد شد) و اگر تایید کنند این شما هستید که برده اید. که البته به شانس وابسته خواهد بود.
در آینده، توسعه دهندگان بیت کوین در نظر دارند کیف پول ها، با توجه به تغییرات بازار و انجام اعمال آماری میزان fee را خود تعیین کنند .
9-4 نحوه ی اختصاص دادن fee
مفهوم اختصاص دادن fee را  با یک مثال مطرح می کنیم اما قبل از آن باید گفت fee را به طور مستقیم معین نمی کنند بلکه مقدار آن از تفریق ورودی ها از خروجی ها به دست می آید .
مثال:
فرض کنید می خواهید 0.15 بیت کوین خرج کنید و برای این کار یک ورودی در کیف پول شما با ارزش 0.2 بیت کوین تعیین شده.
شما 0.15 بیت کوین به آدرس مورد نظر میفرستید و 0.04 بیت کوین به کیف پول خود باز می گردانید(توجه کردید که ساختار تراکنش می تواند چند خروجی داشته باشد )
آیا اینجا شما 0.01 بیت کوین را فراموش کردید؟
خیر بلکه این مقدار در بلاکچین به عنوان fee به ماینری که تراکنش شما را تایید می کند داده می شود.

10-4 تراکنش زنجیره ای و تراکنش های یتیم
فرض کنید تراکنشی انجام می شود که باید ورودی آن از تراکنش دیگری تامین شود که هنوز رخ نداده .
بیت کوین این توانمندی را دارد که زنجیره ای از تراکنش ها را بتواند تایید کند .
یک تراکنش پدر، یک ورودی است به یک تراکنش پسر و یک تراکنش پسر یک ورودی است به تراکنش نوه و همینطور جلو می رود .
گاهی تراکنش پسر وارد بلاکچین می شود وقتی هنوز تراکنش پدر رخ نداده .
گره ها تراکنش پسر را در محلی موقت نگهداری می کنند تا تراکنش پدر وارد بلاکچین شود .
البته هر گره دارای ماکزیمم مقدار ثبت چنین تراکنش هایی است و اگر این ماکزیمم عبور کند بعضی از تراکنش ها حذف می شوند.
محدود بودن چنین فضایی برای جلوگیری از حمله به گره ها می باشد مبادا فردی بخواهد کل فضای یک گره را اشغال کند و آن گره را از کار بیندازد .
تراکنش ها ی زنجیره ای در joincoin  استفاده می شوند .

11-4Joincoin 
ساختاری شبیه به کیف پول دارد منتها یک کیف پول پویا و  نه ایستا.
به این معنا که خودسرانه بین افرادی که عضو joincoin هستند، تراکنش انجام می دهد.
به افرادی که داخل joincoin هستند ، joincoiner می گویند و این افراد دو دسته می شوند . افرادی که عجله دارند برای انجام فرآیند داخل joincoin و افرادی که عجله ندارند.
قبلا گفته بودیم برای افزایش privacy نباید از یک آدرس برای دریافت بیت کوین چندبار استفاده کنیم . شاید شما  به افزایش بیشتر privacy نیاز داشته باشید . برای این کار ،پول خود را در joincoin می گذارید تا بین آدرس های مختلف جا به جا شود تا کار را برای افرادی که ممکن است در حال چک کردن تراکنش های شما هستند سخت کنید و یا حتی آن ها را به خطا بیندازید که انگار بیت کوین ها را خرج کرده اید.
این عملیات را خود joincoin  انجام می دهد که علاوه بر افزایش privacy  اثر دیگری هم دارد.
همانطور که گفتیم افرادی عجله ندارند و افرادی عجله دارند که سریعا فرآیند انجام شود و بتوانند از پول خود استفاده کنند . افرادی که عجله ندارند و بدون دغدغه پول خود را در joincoin  ذخیره کرده اند ، به گونه ای پول خود را بلوکه کرده اند و در ازای این کار از افرادی که عجله دارند ، هزینه دریافت می کنند .(به هر حال مجبورید برای افزایش privacy هزینه بپردازید )
مزیت بعدی آن کاهش عرضه است که با بلوکه شدن بیت کوین در joincoin اتفاق می افتد و همین باعث افزایش ارزش بیت کوین در بازار می شود.

12-4Script 
شاید تا کنون برایتان مبهم بوده که چگونه یک تراکنش تایید و یا رد  می شود . منظور از تایید اینجا ،تایید صاحب کیف پول است. مانند امضا کردن یک چک. در اینجا توضیح می دهیم چگونه یک تراکنش در ساختار بیت کوین در برنامه نویسی انجام می شود .
زبان script یک زبان ساده بوده که برای سخت افزار های embedded  استفاده می شده که بسیار ساده بودند و قرار نبوده که کار پیچیده ای انجام دهند مانند ماشین حساب ها .
در بیت کوین ساختاری شبیه به آن برای تایید تراکنش ها استفاده می شود.
در زبان script  عملیات از چپ به راست انجام می شود و به گونه ای است که ابتدا پارامترها نوشته می شوند که در نتیجه بر روی stack قرار می گیرند و سپس عملیات بر روی stack  قرار می گیرد ،انجام شده ، نتیجه ر روی stack به جای پارامتر ها و عملیات قرار می گیرد.
مثال :
2 3 OP_ADD 5 OP_EQUAL

ابتدا 2 بر روی stack  و سپس 3  بر روی stack و سپس add بر روی stack قرار گرفته و سپس  جواب آن که 5 است بر روی stack  قرار می گیرد .
پارامتر 5 دیگری بر روی stack  قرار می گیرد و عملگر  equal انجام می شود که عملیات شرطی است .
سپس true که نشانه ی برابر بودن دو 5 با یکدیگر است بر روی stack  قرار می گیرد .
ترتیب عملیات بالا که به زبان script  نوشته شده با عکس زیر توضیح داده شده .
 
شکل 4-1 نحوه ی اجرای یک برنامه به زبان script
13-4 ساختار script در بیت کوین
برای خرج کردن یک بیت کوین ، باید یک UTXO را انتخاب و بلاکچین آن را به Input متصل کند و در UTXO قسمتی به نام locking_script داشتیم و درinput قسمتی به نام unlocking
script داشتیم که اگر locking_script  را ارضا می کرد و یا بهتر بگوییم حل می کرد ، آنگاه آن UTXO از قسمت unspent در می آمد و به قسمت  spent می رفت.
UTXO هایunspent  بر روی ram سیستم قرار می گیرند برای انتظار spent شدن و  در نتیجه از روی ram  پاک شدن.
نام قدیمی locking script ، scriptPubKey بود به این علت که در آن از خود کلید عمومی برای آدرس استفاده کرده می کردند.
نام قدیمی unlocking script  هم script-sig  است که علت آن وجود امضا در این قسمت بود البته به طور عام  و در حال حاضر حتما نباید در این قسمت امضا قرار بگیرد . که بسته به نوع پرداخت می باشد که بعدا در این باره صحبت می شود.(مراجعه شود به قسمت Coinbase transaction)
نام قدیمی این script  ها همان هایی است که در کد  منبع بیت کوین کور از آن ها استفاده می شود .

UTXO فراخوانی می شود که در خود locking script دارد و سپس input فراخوانی می شود که unlocking script  دارد.
روش قدیمی :
ابتدا locking script و unlocking script به هم می پیوندند (concatenate)


 
شکل 4-2 قرار گیری locking  و unlocking در کنار یکدیگر
سپس script انجام می شود و اگر true بر روی  stack قرار گرفت بیت کوین کور آن تراکنش را valid ثبت می کند . سپس به بلاکچین فرستاده می شود برای انجام confirmation  که این کار را ماینر ها انجام می دهند .
روش جدید:
به دلایل امنیتی و اینکه اگر locking  و unlocking ، concatenate شوند ممکن است مورد خدشه قرار بگیرند ناکاماتو روش تایید تراکنش را تغییر داد به این صورت که
ابتدا unlocking script  اجرا می شود و جوابش بر روی stack قرار می گیرد سپس stack کپی شده ، به جایی برده می شود locking script  قرار دارد و سپس locking script اجرا می شود .

زبان script  استفاده شده در بیت کوین بدون اعمال شرطی و حلقه ای است مبادا کسی بخواهد با فرستادن یک script که دارای حلقه ی بی نهایت است به سیستم حمله کند.
همچنین این زبان در بیت کوین stateless استفاده می شود .

14-4 تراکنش های استاندارد
کلا 5 نوع تراکنش در بیت کوین می توان ثبت کرد و استاندارد بودن آنها توسط تابعی به نام isstandard() چک می شود.
1.	Pay to Public Key Hash (P2PKH)
2.	Pay-to-Public-Key
3.	Multi-Signature
4.	Data Output (OP_RETURN)
5.	Pay to Script Hash (P2SH)
1-14-4 نوع اول
ساختار script نوع اول :
<Cafe Signature> <Cafe Public Key> OP_DUP OP_HASH160 \
<Cafe Public Key Hash> OP_EQUAL OP_CHECKSIG

خط بالاunlocking  و خط پایین locking  است.
خط بالا حاوی امضا ، کلید عمومی ، عملگر duplicate که کلید عمومی را کپی کرده و بار دیگر بر روی stack می گذارد ، و عملگر hash160  که همان RIPEMD160(SHA256(PUBK)) است که بر روی پارامتر بالایی stack  که همان پارامتر کپی شده است اجرا می شود.
خط پایین حاوی کلید عمومی هش شده و عملگر تساوی وعملگر چک کننده ی صحیح بودن امضا می باشد .
توضیحات بیشتر درتصویر زیر :

 
شکل 4-3 اجرای پروسه ی امضا
 
شکل 4-4 ادامه ی اجرای پروسه ی امضا
2-14-4 نوع دوم
تراکنش شبیه نوع اول است و قدیمی تر از نوع اول و تنها فرق آن در استفاده ی خود کلید عمومی به جای هش شده ی آن در locking script  است
علت به وجود آمدن نوع اول به جای نوع دوم ، کمتر شدن فضایی است که UTXO  اشغال می کند .
Script  آن به صورت زیر است
<Signature from Private Key A> <Public Key A> OP_CHECKSIG
3-14-4 نوع سوم
چند امضا می خواهد برای آنکه یکئ تراکنش انجام شود و تعداد امضاهای آن محدود به 15 عدد می باشد .
اگر تعداد 5 امضا داشته باشیم که از این 5 امضا باید 3 امضا انجام شود تا تراکنش اعمال شود به آن امضا 3-of-5 multi-sig می گویند . اگر N  کل امضاها و M حداقل تعداد امضاها باشد یک locking script به صورت زیر باید تشکیل شود.
M <Public Key 1> <Public Key 2> ... <Public Key N> N OP_CHECKMULTISIG
و unlocking script به صورت زیر
OP_0 <Signature B> <Signature C>….
4-14-4Data Output (OP_RETURN) 
بعضی پروژه ها خواستند برای افزایش امنیت خود از بلاکچین استفاده کنند و برای این کار UTXO هایی تشکیل دادند که به هیچ input نمی خورد و هیچکدام از آنها را حل نمی کرد و باعث می شد ram سیستمی که روی آن بیت کوین کور موجود است بی مورد پر شود. بعضی از توسعه دهندگان موافق وجود چنین چیی شدند چون تبلیغی بود برای امنیت بلاکچین ولی بعضی مخالف بودند زیرا گره ها را مجبور می کرد سیستم های گرانتری به علت بالاتر رفتن قیمت ram داشته باشند . درعین حال این پروژه ها مانند digital   notary services, stock certificates و  smart contracts از 20 کیلو بایت داده ی UTXO استفاده می کردند .
برای حل این موضوع ناکاماتو و این پروژه ها به توافقی رسیدند و ناکاماتو  عملگری در زبان script  تولید کرد تا وقتی گره ها به آن برخورد می کردند تراکنش را invalid می دانستند و آن را به حافظه دائم سیستم میفرستادند . ناکاماتو برای ترغیب این پروژه ها 40 کیلوبایت حافظه را برای این اطلاعات تعیین کرد به جای 20 کلوبایت.
این کار به جای گرفتن حافظه ی ram ، حافظه ی دائم سیستم را اشغال می کرد. در هر حال بلاکچین از آن چیزی که تصور میرفت بزرگتر خواهد شد به علت استفاده ی این چنینی.
البته ناگفته نمایند ارز رمز های دیگر مانند etherum و namecoin عملا یکی از اهداف خود را ارسال و دریافت این چنین اطلاعاتی را در بلاکچین خود قرار داده اند و مانند بیت کوین مشکلی با این موضوع ندارند .
قبل از رفتن به سر اصل موضوع که آن عملیات mining  است بهتر است در مورد دو اصطلاح توضیحاتی بدهم البته ربطی به ماینینگ ندارند و هدف فقط خالی نماندن عریضه است .
15-4Testnet 
شاید شما به عنوان یک توسعه دهنده یا تمرین کننده برای وارد شدن به عرصه ی بیت کوین نیاز داشته باشید قبل از به خطر انداختن اموال خود ، مکانی را برای تمرین و یا آزمایش داشته باشید که شبیه به بیت کوین باشد .
Testnet چنین مکانی است .
منتها ارزرمز های تولید شده در این محیط هیچ ارزشی ندارند و حتی این قابلیت را دارند که به صورت رایگان از افراد دیگری که این ارزرمز را دارند گرفته شود .
به چنین محل هایی که می توان ارزرمز testnet  را دریافت کرد faucet می گویند .
زمانی faucet  هایی وجود داشت که مقدار جزئی بیت کوین با ارزش(غیر testnet) در اختیار متقاضیان قرار میداد منتها اکنون این قابلیت از کار افتاده است.
Testnet با محیط بیت کوین چند تفاوت دارد :
•	Default Bitcoin network protocol listen port is 18333 (instead of 8333)
•	Default RPC connection port is 18332 (instead of 8332)
•	Bootstrapping uses different DNS seeds.
•	A different value of ADDRESSVERSION field ensures no testnet Bitcoin addresses will work on the production network. (0x6F rather than 0x00)
•	The protocol message header bytes are 0x0B110907 (instead of 0xF9BEB4D9)
•	Minimum difficulty of 1.0 on testnet is equal to difficulty of 0.5 on mainnet. This means that the mainnet-equivalent of any testnet difficulty is half the testnet difficulty. In addition, if no block has been found in 20 minutes, the difficulty automatically resets back to the minimum for a single block, after which it returns to its previous value.
•	A new genesis block
•	The IsStandard() check is disabled so that non-standard transactions can be experimented with.





















فصل پنجم
Mining 




شاید دیده باشید دستگاه های ماینری را که اکثرا حروف چینی بر روی آنها نوشته شده .
این دستگاه ها هر روز پیشرفته تر میشوند و بازده انرژِی آنها اکنون چند ده برابر دستگاه های اولیه است و حتی بعضی از آنها را با asic  های 7 نانومتری ساخته اند.
شرکت های تولید کننده ی چنین دستگاه هایی عمدتا سایت هایی هم دارند تحت عنوان mining_pool که این دستگاه ها را باید به mining pool ها وصل کرد تا عملیات mining  را شروع کنند.
این mining pool  ها حتی می توانند قدرت دستگاه شما را مانیتور کنند و به شما نشان دهند.
کافیست یک کیف پول در همان سایت ها و یا در جایی دیگر و یک عدد یا یک مزرعه از ماینر ها و یک حساب  در این سایت ها داشته باشید تا بتوانید عملیات ماینینگ ر انجام دهید .
ولی در این حالت شما نمی دانید چگونه این عملیات در حال انجام است . چه اتفاقی در حال رخ دادن است ؟
روزی در خبری از صدا و سیما به اشتباه گزارشگر ماینر ها را سرور خطاب کرد.
بهتر است دیگر چنین خطا هایی دیگر بین ایرانیان رواج نداشته باشد و شاید اگر اطلاعات ایرانیان بالاتر برود دیگر قبل از آن که به مانند دیگر تکنولوژی هایی که فرهنگ سازی برای آنها اتفاق نیفتاده  خطر ساز نخواهد شد.
چه بخواهیم و چه نخواهیم این تکنولوژی خطراتی را برای جامعه ایجاد می کند . از جمله تحت نظر نبودن تراکنش ها و انجام اعمال مجرمانه و راحت تر شدن و سریعتر شدن عملیات پولشویی و...
دیگر خطر آن امکان خروج سرمایه از یک کشور است .
اگر ارز را در کشور تحریمی مانند ایران به صورت فیزیکی خارج می کردند ، دیگر نیازی نیست این زحمت را به جان خود بخرند . تمام دارایی آن ها بر روی دستگاهی به سبکی پر قو ذخیره موجود است ( کیف پول های  usb)
ولی مزیت هایی هم دارد از جمله:
شرکت هایی در ایران پدیدار شوند که از این طریق تجارت انجام میدهند و خدمات ارائه می دهند. به زبان دیگر ایجاد شغل .
همچنین روشی پدیدار می شود برای انجام تراکنش های بین کشوری بدون دخالت کشور های پر قدرت یعنی سرکوب کردن تحریم ها .
حتی تا جایی می توان پیش رفت که دلار تنها در خود آمریکا ارزش داشته باشد و از آنجا که ارزش دلار را تراکنش هایی مشخص می کند که به وسیله ی آن انجام می شود و این حقیقت که دلار بدون پشتوانه چاپ می شود ، عملا دلار بی ارزش خواهد شد.
و شاید بگویید ممکن است اینترنت را به روی ایران ببندند و دیگر ایران نتواند تراکنش بیت کوینی انجام دهد ولی بهتر است بدانید حتی اگر این اتفاق بیفتد ، راه های دیگری برای ارسال و دریافت بلاکچین وجود دارد که قابل suspend شدن نیست .
از مزیت های دیگر آن حذف چک های بی محل است. فقط وقتی می توانید بیت کوینی را خرج کنید که آن مقدار را در کیف پول خود داشته باشید.
1-5 توجه به عمر بیت کوین
در آینده ناکاماتو باید فکری به حال عمر بلاکچین بکند زیرا در تراکنش ها و عملیات بانکی از unix_time  که 32 بیتی است استفاده می شود که این موضوع عمر بیت کوین را محدود می کند .
و یا در نحوه ی ارسال تراکنش ارتفاع بلوک ها را محدود کرده است و این نیز مورد دیگری است که عمر بیت کوین را محدود می کند .
البته ناکاماتو همیشه در طول زمان در کد منبع دست برده و باز هم این کار را خواهد کرد و خطری نیست که بیت کوین را تحدید کند مگر آنکه قبل از تمام شدن عمرش این کار را انجام ندهد و یا کلید تغیرات را در اختیار فرد دیگری قرار ندهد .
قبل از پرداختن به ماینینگ باید اطلاعات دیگری را نیز با هم مرور کنیم و آن اطلاعات نحوه ی کار کردن بلاکچین است .
2-5Consensus 
قوانینی که بلاکچین بر اساس آن کار می کنند rules  consensus می گویند.
در ادامه با آنها آشنا می شویم.
تصویر  زیر ساختار ساده بلاکچین را تشکیل می دهد .
داخل هر بلوک، هش بلوک قبلی و merkle root که از انجام عملیات merkle tree که بعدا توضیح داده می شود وجود دارد .
Merkle root از روی txid تراکنش هایی ساخته می شود که داخل همان بلوک قرار دارد.

 
شکل 5-1 یک بلاکچین ساده با سه بلوک
استفاده از هش بلوک قبلی در یک بلوک باعث می شود بلوک قبل غیر قابل ویرایش و تغییر باشد.
TXID  ها ، هش شده ی تراکنشی هستند که امضا شده باشد . یعنی بعد از تایید یک تراکنش و وارد شدن UTXO از گروه unspent به spent می توان TXID ها را محاسبه کرد و آن ها را در به دست آوردن merkle root  استفاده کرد.
3-5Proof of work 
در بلوک ها ی بالا می بینید که یک فلش از یک بلوک به بلوک بعدی رفته و نوشته شده هش بلوک قبلی .
ساختار بیت کوین به گونه ای طراحی شده که برای به دست آوردن این هش ، محاسبات فراوانی باید انجام بگیرد و علت انجام چنین محاسبات سنگین برای جلوگیری از این است که اگر کسی بخواهد بلوک قبل از این بلوک که با محاسبات در حال تشکیل آن هستیم ، را تغییر دهد مجبور باشد علاوه بر تغییر بلوک قبلی، بلوک فعلی را هم تغییر دهد و این غیر ممکن است .
غیر ممکن بودن آن برای این است که توان همه ی ماینر ها روی تشکیل بلوک فعلی قرار داده شده و شما اگر بخواهید بلوک قبلی را تغییر دهید و به علت خروجی هش متفاوت از بلوک قبلی تغییر داده شده ، مجبور هستید بلوک فعلی را هم تغییر دهید .
این فقط وقتی می تواند رخ دهد که توان محاسباتی شما از کل افرادی که در حال محاسبات برای تشکیل بلوک فعلی هستند ،بیشتر باشد ؛ که عملا غیر ممکن است. یعنی شما برای این کار باید 51 درصد از کل قدرت ماینینگ را داشته باشید.
به علت محاسبات بالایی که باید برای تشکیل یک بلوک انجام شود ، به الگوریتم تشکیل بلوک جدید ، proof of work  می گویند .
کلیت الگوریتم بر مبنای هش کردن بلوک هدر است که حاوی اطلاعات تراکنش ها و هش بلوک قبلی است.
باید آنقدر عملیات هش کردن بلوک هدر تکرار شود تا بالاخره خروجی هش مقداری کوچکتر از target value باشد.
Target value توسط شبکه ی بلاکچین تعیین می شود و هر دو هفته یکبار تغییر می کند .
ناکاماتو به ابن فکر کرده بود که ممکن است قدرت محاسباتی سخت افزار ها در آینده بسیار بالاتر برود و نمی خواست شبکه به همین راحتی دچار تغییر شود . چون بالا رفتن قدرت محاسباتی همانا و راحت تر شدن تغییر بلوک ها همان.
ناکاماتو می خواست هر بلوک به طور متوسط 10 دقیقه زمان ببرد تا ماینر ها به مقداری کوچکتر از target value برسیند .
از آنجا که زمان دست یافتن به مقداری کوچکتر از یک عدد باینری را می توان با احتمال و دانستن قدرت شبکه  به دست آورد ، با تغییر target value  شبکه می تواند زمان رسیدن به جواب را تغییر دهد.
خروجی هش sha256 که در عملیات ماینینگ بیت کوین استفاده می شود دارای 256 بیت اطلاعات است.
پس target value  هم یک عدد 256 بیتی می باشد که تعدادی ازبیت های پر ارزش آن صفر می باشد .
نحوه ی تعیینtarget value به این صورت است: بعد از گذشت هر 2016 بلوک ( که زمان مورد علاقه برای هش شدن آن ها 20160 دقیقه است) (هر بلوک 10 دقیقه) زمانی که گذشته تا این 2016 بلوک هش شوند توسط شبکه محاسبه می شود .
20160 دقیقه همان دو هفته می شود.
اگر این مقدار از 20160 دقیقه بیشتر باشد ، target value افزایش می یابد که به معنی کاهش difficulty است و بر عکس اگر کمتر از این مقدار باشد ، target value  کاهش می یابد که به معنای افزایش difficulty  است.
4-5Forking 
تصاویر زیر نشان دهنده ی اتفاقی در بلاکچین به نام forking هستند.
زمانی که دو ماینر به صورت کاملا همزمان بتوانند یک بلوک بسازند ، forking اتفاق افتاده . یعنی دو بلوک کاملا جداگانه توانسته اند ارتفاع یکسان به خود بگیرند.
 
شکل 5-2 اتفاق forking در حین ماینینگ
زمانی که این اتفاق می افتد ، ماینر ها مختارند کدام بلوک را برای تشکیل بلوک بعدی استفاده کنند.
شاید به این اشتباه بیفتید که اگر دو بلوک دارای ارتفاع یکسان باشند در نتیجه دارای هش یکسانی هم هستند ولی این اتفاق غیر ممکن خواهد بود اگر در نظر بگیریم:
1.	متفاوت بودن تراکنش Coinbase که حاوی اطلاعات کیف پول ماینر است .
2.	تاثیر Coinbase در تشکیل merkle root
3.	تفاوت ماینر ها
4.	خروجی کاملا متفاوت در صورت داشتن دو ورودی کاملا متفاوت در صورت گذر از یک هش
تمامی موارد بالا مجموعا نشانه ی یکسان نبودن هش دو بلوک همزمان است.
در حالت عادی ماینر ها شاخه ای را انتخاب می کنند که دارای ارتفاع بالاتری باشند و شاخه ی کوتاه تر orphan  یا stale  شناخته می شوند.
ولی در حالت غیر عادی دو شاخه همزمان به جلو رانده می شوند و یکی از زمان هایی که ممکن است این اتفاق بیفتد ، زمانی است که فردی در حال دستکاری بلاکچین است که یعنی دارای 51 درصد از قدرت محاسباتی است.
5-5 جایزه ی ماینر ها
وقتی یک بلوک تشکیل می شود ، بلاکچین یک جایزه که قسمتی از آن fee هایی است که داخل تراکنش ها ثبت شده ، و قسمتی دیگر از آن بیت کوین های تازه تشکیل شده است  را به آدرس Coinbase میفرستد.
قسمت بیت کوین های تازه تشکیل شده ، قوانین خاصی دارد از جمله اینکه هر 4 سال یکبار این مقدار نصف می شود. در ابتدا در سال 2009 ، 50 بیت کوین بوده و اکنون که 2019 می باشد 12.5 بیت کوین است.
و دیگر این که تا تشکیل 100 بلوک بعدی قابل خرج کردن نیست .برای این که مشخص شود بلوکی که ماینر تشکیل داده بعدا جزو بلوک های stale نخواهد بود.
6-5Merkle tree 
با گرفتن  دوبار هش  sha256 از raw transaction ، txid تشکیل می شود و txid ها برای تشکیل merkle root  استفاده می شوند.
 
شکل 5-3 عملیات merkle tree
اگر بخواهیم 5 تراکنش با txid  های A,B,C,D,E را در بلوک خود قرار دهیم ، جفت ، جفت txid ها concatenate شده و دو بار از sha256 عبور می کنند که اگر آن جفت ها A  و B باشند ، حاصل آن ها AB خواهد بود.
اگر هیچ جفتی نباشد که با آن concatenate اتفاق بیفتد ، باید با کپی خود concatenate کند مانند E  .
مرحله ی بعد هم دوباره همین اتفاق می افتد تا در انتها به یک خروجی برسیم که به آن merkle root  می گویند.
7-5Consensus rules change 
بعضی مواقع ناکاماتو به روزرسانی  هایی برای ایجاد ویژگی هایی اضافه و یا کم می کند و گره ها باید بیت کوین کور را آپدیت کنند و گرنه مشکلاتی برای آن ها اتفاق خواهد افتاد .
وقتی یک تغییر اتفاق می افتد ، کلاینت های قدیمی اطلاعاتی که گره های جدید می فرستند را قبول نمی کند و بالعکس.
در این حال دو جور به روزرسانی ممکن است رخ دهد.
1.	Hard fork
2.	Soft fork
اگر اکثریت شبکه را گره های به روزرسانی شده تشکیل دهند ، شعبه های تشکیل شده بر روی بلاکچین توسط گره های به روزرسانی شده اتفاق می افتد . که soft fork اتفاق افتاده و بلوک های تشکیل شده توسط گره های قدیمی ، orphan  خواهند شد. مانند تصویر زیر
 
شکل 5-4 یک soft fork
و اگر قدرت به روزرسانی شدگان و قدیمی ها یکسان باشد ، در بلاکچین دو شعبه به صورت همزمان جلو میروند که hard fork اتفاق افتاده که اصلا اتفاق خوبی نیست.
در این مواقع ناکاماتو برای جلوگیری از hard fork ابتدا به روزرسانی هایی تولید می کند که هم از قوانین قبلی و هم از قوانین جدید پیروی کند و بعد از آنکه گره های به روزرسانی شده اکثریت را تشکیل دادند، قوانین قدیمی دیگر پذیرفته نخواهند شد مانند تصویر زیر:
که نتیجه یک soft fork خواهد بود.
 
شکل 5-5 روشی برای جلوگیری از hard fork (نوعی soft fork)
دو جور soft fork ممکن است رخ دهد :
1.	User Activated Soft Forks
2.	Miner Activated Soft Forks
نوع اول وقتی است که ناکاماتو روزی را به عنوان flag day تعیین می کند برای حذف قوانین قدیمی
نوع دوم وقتی است که اکثریت ماینر ها از قوانین جدید استفاده می کنند و آن زمان است که دیگر قوانین قدیمی نادیده گرفته خواهند شد.
راه های تشخیص برای گره های قدیمی:
به روزرسانی ها دو جور توسط full nodes های قدیمی تشخیص داده می شوند.
1.	در صورتی که یک گره ، بلوکی را دریافت کند که ارتفاعش 6 عدد بالاتر از بلوک هایی باشد که در خود دارد
2.	در صورت دریافت یک بلوک ، قسمت version  از بلوک هدر  را نگاه می کند و در صورت تشخیص مغایرت یک خطا  اتفاق می افتد.
8-5Solo  و pool
دو جور عملیات استخراج ممکن است رخ دهد
1-8-5Solo 
یک نفر با سخت افزار خودش و به تنهایی مشغول به عملیات ماینینگ شود که در نتیجه جایزه را در صورت رسیدن به هش ، کاملا خودش بر می دارد.
این افراد برای دریافت اطلاعاتی که برای هش کردن یک بلوک لازم است ، به طور مداوم دستور getblocktemplate که از دستور های bitcoind است  را بر روی نرم افزار اجرا می کنند و توسط نرم افزار به همراه target threshold  به   asic  ( یا هر ماینر دیگری )می دهند بعد از هش شدن  nonce را که قسمتی از بلاک هدر است به نرم افزار میفرستد و نرم افزار اطلاعات بلوک و nonce را به bitcoind میفرستد.
 
شکل 5-6 سلسله مراتب solo mining
2-8-5Pool 
افراد در مکانی به نام mining pool جمع می شوند و توان سخت افزاری خود را روی هم می گذارند و در انتها pool جایزه را به نسبت توان سخت افزاری که هر فرد گذاشته جایزه را تقسیم می کند.
 
شکل 5-7 سلسله مراتب pool mining
در این حالت mining pool بلوک ها را به نرم افزار کامپیوتر می دهد و بین bitcoind و عضو pool واسط است.
روش های دریافت اطلاعات برای ماینینگ
برای این کار یک روش قدیمی هست که تقریبا از کار افتاده و آن استفاده از getwork می باشد .
اگر قرار است کسی از آن استفاده کند ، ماینر های solo هستند.
اطلاعاتی که این دستور در اختیار ما می گذارد یک بلوک هدر کامل است که ما این اطلاعات را می گیریم و تنها عملیات هش را روی آن انجام می دهیم.
هر بار برای انجام هش بر روی یک بلوک لازم است این دستور را اجرا کنیم.
که نشان از کند بودن این روش است.
روش دیگرGetblocktemplate است که اطلاعات کلی به ما می دهد از جمله :
1.	اطلاعات مورد نیاز برای تشکیل coinbase transaction
2.	تمام txid ها ؛که اجازه می دهد ماینر خودش txid ها ی مورد علاقه اش را انتخاب کند.
3.	اطلاعاتی که برای تشکیل بلوک هدر  لازم است مانند: هش بلوک قبلی و target و نسخه بلوک
خیلی ها از  HTTP longpollبرای باز نگه داشتن این دستور استفاده می کنند تا اگر تراکنشی جدید ایجاد شد  و یا بلوک جدیدی تشکیل شد خبر دار شوند.
و روش دیگر:
Stratum است که تفاوت آن با longpoll getblocktemplate  در این است که نمی توان تراکنش جدیدی را دریافت کرد و merkle root   جدیدی تشکیل داد.
5-9Block Header 
یک اطلاعات باینری 80 بایتی که ماینر ها برای رسیدن به عددی کوچکتر از target روی آن عملیات هش انجام می دهند.
از سال 2015 نسخه چهارم ارائه شده است. در bip93 نحوه ی انجام soft fork برای جایگزینی نسخه چهار را توضیح داده . پس در قسمت نسخه باید عدد 4 گذاشته شود مگر آنکه ناکاماتو هوس کند دوبار آن را تغییر دهد. در صورتی که به blockchain.info سری بزنیم ، هنوز تعداد زیادی از نسخه 2 استفاده می کنن.
هش بلوک قبلی یک اطلاعات 32 بایتی است به علت آنکه خروجی sha256 است.
همچنین merkle root 32 بایتی است چون آن هم با استفاده از sha256  تولید می شود.
Time : زمانی است که ماینر شروع به هش کردن کرده که به فرمت unix نشان داده می شود.
nBits: قسمتی از انکد شده ی target threshold  است.
Nonce: یک فیلد 4 بایتی است که از صفر شروع شده و تک تک اضافه می شود و بعد از هر اضافه شدن ، هش آن حساب می شود و چک می شود که آیا هش حساب شده کمتر از target می باشد یا خیر.
همه ی قسمت های block header به فرمت little-endian هستند به غیر از merkle-root و هش بلوک قبلی که به فرمت internal byte order خواهد بود.
بلوک هدر در تصویر زیر نشان داده شده .
 
شکل 5-8 اجزای block header
اگر تمام 4 بایت را امتحان کردیم و به جواب دلخواه نرسیدیم، سه راه داریم:
1.	در coinbase transaction که نام دیگر آن generation transaction است محلی به نام nonce  وجود دارد که غیر از nonce field موجود در block header  است. باید این قسمت را تغییر داد و دوباره merkle root رو تشکیل داد. و دوباره عملیات را با شروع nonce از صفر انجام داد.
2.	می توان یک تراکنش به تراکنش های قبلی اضافه کرد و دوباره merkle root را تشکیل داد.
3.	ترکیبی از دو مورد بالا
Genesis block که اولین بلوک تشکیل شده در بیت کوین است و توسط ناکاماتو تشکیل شده ، قبلش هیچ تراکنشی وجود نداشته به همین دلیل nonce field داخل coinbase  قرار داده شد تا اگر nonce داخل block header کافی نبود و به جواب نرسید ، از آن قسمت استفاده شود.
همچنین از آنجا که داخل genesis block تراکنشی جز Coinbase وجود ندارد، می توان فهمید برای تشکیل بلوک حتما نیاز نیست که تراکنش ها را  برای تشکیل     merkle root استفاده کرد .
اگر تنها از تراکنش Coinbase  استفاده می کنیم نیازی به هش گرفتن نیست و خود Coinbase  رو داخل merkle root  میگذاریم.
توجه : هنگام محاسبه ی merkle root همه ی txid ها باید به فرمت internal byte order  باشند و در همین فرمت از آنها merkle root گرفته می شود.
 
شکل 5-9 عملیات merkle tree
توجه کنید که تابع H   در بالا دو sha256 تو در تو می باشد.
البته انجام عمل ماینینگ تا زمانی کار عاقلانه ای است که جایزه ی ساخت بلوک جدید به اندازه ی کافی باشد . تا 40 سال دیگر این جایزه به صفر میرسد و از آن به بعد درآمد ماینر ها تنها از طریق fee های تعیین شده در تراکنش ها خواهد بود.
محاسبه ی merkle root  زمان خاصی از ما نمی گیرد ؛ پس چرا از دریافت مقدار بیشتری بیت کوین امتناع کنیم؟ تعداد بیشتری تراکنش fee دار اضافه می کنیم تا همزمان با دریافت reward ، fee ها را هم به دست بیاوریم.
قبلا گفته بودیم هنگام ارسال بیت کوین به یک آدرس مختاریم برای تراکنش fee  قرار بدهیم یا خیر و گفتیم تراکنش ما تنها در شرایط خاص تایید خواهد شد .
آن شرایط خاص وقتی است که فردی تمام تراکنش های fee دار را در ساخت merkle root استفاده کرده باشد و به جواب نرسیده باشد و تنها تراکنشی که fee ندارد را اضافه می کند تا merkle root را برای رسیدن به جواب تغییر دهد.

10-5Serialize block 
در انتها این serialized block است که بعد از رسیدن به جواب به بلاکچین فرستاده می شود و در consensus rule فعلی نباید سایز آن از 1 مگابایت بیشتر باشد.
پس با این حساب در اضافه کردن تراکنش ها به بلاک هدر محدودیت وجود دارد.
 
شکل 5-10 serializes block
11-5Unix_time 
تعداد ثانیه ای که از یکم ژانویه 1970 تا به حال گذشته را unix_time  می گویند. unix را نباید با gmt و یا زمان اتمی اشتباه گرفت.
ساعت اتمی در سال های قبل از 1970 ابداع شد برای آن که به طور دقیقی زمان را بتواند محاسبه و نگه دارد. اما در سال 1972 به این موضوع پی بردند که زمان گردش زمین به دور خودش در حال تغییر است به همین علت نیاز بود که در تاریخ های خاصی این زمان به روزرسانی شود. در حقیقت می توان گفت unix به روزرسانی شده ی ساعت اتمی جهانی است .
بحث gmt  جدا از همه است . این نوع تفصیل ساعت کاملا با وضعیت زمین منطبق است و اصلا نیازی به به روزرسانی ندارد.
نحوه ی به روز رسانی unix را می توانید در جدولی در سایت ویکی پدیا مشاهده کنید.
12-5Little_endian 
نحوه ی ذخیره سازی اطلاعات در سیستم های مختلف متفاوت است . در بعضی little-endian و در بعضی big-endian می باشد و حتی در بعضی هر دو .
به این معنا که در ساختار big-endian  ابتدا بایت های با ارزش بالاتر فراخوانی می شود و در مکانی با آدرس کوچکتر ذخیره می شود و در little-endian   بالعکس. در تصویر زیر می توان تفاوت را مشاهده کرد.
 
شکل 5-11 little-endian  و big-endian
13-5Internal_byte_order 
شبیه به little_endian است ولی در bitcoin.org نام خاصی برای آن قرار داده چون خروجی هش می باشد.
14-5nBits 
فرمتی شبیه به floating point  دارد که در مثال زیر نشان داده چگونه از nbits به target threshold برسیم
و گفته ابتدا از little _endian به big_endian  تغییر باید داد و سپس محاسبه نمود.

 
شکل 5-12 تبدیل nbits به target
15-5 ماینر داخلی
بیت کوین کور خود دارای یک ماینر داخلی است اما عملیات ماینینگ را با CPU انجام میدهد که عملا به کار نمی رود.
دستوری برای این کار داخل bitcoind وجود دارد به نام setgenerate
بین ماینر ها ی موجود در بازار می توان مقایسه انجام داد که از لینک زیر قابل دسترسی است.
https://en.bitcoin.it/wiki/Mining_hardware_comparison










فصل ششم 
پیاده سازی عملی




1-6 نصب بیت کوین کور
برای نصب بیت کوین فایل نصبی از آدرس https://bitcoin.org/en/download
دریافت می شود که آخرین نسخه در هر بار دانلود به دست می آید.
 
شکل 6-1 سایت bitcoin.org و محل دانلود فایل نصبی
فایل نصبی exe  را در محل دلخواه نصب می کنیم.
 
شکل 6-2 محل دلخواه نصب بیت کوین کور
با اجرای bitcoin-qt.exe محیط gui کیف پول باز می شود و اطلاعات بلاکچین شروع به دانلود می کند .
ولی نمی توان بر روی روند دانلود نظارت داشت برای بهتر دیده شدن روند باید مسیر:\ProgramFiles\Bitcoin\daemon را به path  ویندوز در environment variables  اضافه کرد .
 
شکل 6-3 پوشه ی daemon در مسیر نصب حاوی زیر برنامه های bitcoin core
در مسیر بالا چهار زیر برنامه وجود دارد .
برای ارتباط با بلاکچین اطلاعات توسط bitcoind.exe دانلود به کاربران از طریق  json rpcداده می شود .
با کلیک بر bitcoind.exe محیط cmd  باز شده و دانلود اطلاعات شروع می شود.
ولی اگر بدون انجام تنظیمات این کار را انجام دهیم بلاکچین در فضای پیشفرض یعنی  در مسیر تصویر زیر که در درایو c می باشد دانلود می شود .
توجه : پوشه ی appdata  پیشفرض hidden می باشد.
 
شکل 6-4 محل دانلود پیشفرض بلاکچین
برای انجام تنظیمات دو راه وجود دارد :
1.	استفاده از cmd که راهکاری یک بار مصرف است. در این روش ابتدا برای دانستن انواع تنظیمات bitcoind  عمل زیر را در cmd  انجام میدهیم .
bitcoind -help



 
شکل 6-5 اجرای -help در cmd
به این روش bitcoind  اجرا نمی شود و گزینه های تنظیم مختلف از جمله -pruning  و -testchain    و ... را نمایش می دهد.
دستورات و تنظیمات در محیط cmd باید به همراه dash باشند .
برای انجام تنظیمات باید تمام تنظیمات بعد از کلمه ی bitcoind  پشت سر هم نوشته شوند به طور مثال:
 
شکل 6-6 انجام تنظیمات bitcoind داخل cmd

2.	استفاده از configuration file  که در شکل 6-4  bitcoin.conf می باشد که هر بار با باز شدن bitcoind این تنظیمات خوانده شده و اعمال می شود.

اگر در محل نصب بیت کوین کور برویم پوشه ی doc را می بینیم که یک توضیح اجمالی در باره ی اجزای بیت کوین کور می دهد . ما با پوشه ی انتخاب شده ی زیر کار داریم.
 
شکل 6-7 پوشه ی release notes
که توضیحاتی در باره ی چگونگی تنظیمات bitcoind  می دهد .
به طور مثال :
نام آن باید bitcoin.conf باشد .
یا اگر فایل تنظیمات محل دانلود بلاکچین را تغییر دهد و اگر در آن مکان هم یک فایل تنظیمات دیگر باشد ، اعمال می شود . و می گوید که تنظیمات اولین فایل اولویت خواهد داشت.
اینکه همان تنظیمات داخل cmd می  تواند داخل این فایل باشد بدون وجود dash
اینکه می توان comment وارد کرد با استفاده از # در ابتدای آن
اینکه استفاده از مقدار در فایل تنظیمات الزامی است ولی در cmd خیر . به طور مثال اگر بخواهم اطلاعات testnet  را دانلود و استفاده کنیم در محیط cmd  می توان نوشت :
>bitcoind -testnet
یا
>bitcoind -testnet=1
ولی داخل فایل تنظیمات حتما باید نوشته شود :
testnet=1
اینکه هر تنظیمات باید در خط جداگانه نوشته شود .
برای مثال من یک فایل تنظیمات به صورت زیر دارم :
 
شکل 6-8 داخل پوشه ی bitcoin.conf
البته اطلاعات مربوط به اتصال rpc از فایل برای امنیت پاک شده که چهار خط اول می باشد.
خط پنجم محل دانلود بلاکچین را تغییر می دهد تا مشکل حافظه در درایو ویندوز ایجاد نشود.
و خط ششم قابلیت pruning را فعال می کند.
2-6 تنظیمات bitcoind
pruning  به معنای حَرَص کردن می باشد و راهکاری برای جلوگیری از دانلود تمام اطلاعات بلاکچین البته به بهای از کار افتادن تعدادی از rpc command  ها .
در محل نصب بیت کوین کور و در پوشه ی doc و از داخل این پوشه، پوشه ی release-notes می توان به تعدادی از  release note  های نرم افزار دسترسی پیدا کرد .
راهی دیگر برای دسترسی به تمامی آن ها از طریق آدرس
https://github.com/bitcoin/bitcoin/tree/master/doc/release-notes
می باشد.
 
شکل 6-9 داخل release note نسخه 0.11.0
اگر release-notes-0.11.0.md را باز کنید و notable changes را جستوجو کنید pruning را توضیح می دهد.
توضیحات بدین شرح است :
یک بلوک دارای چهار نوع اطلاعات است :
1.	raw blocks
2.	undo data
3.	block index
4.	UTXO set
با فعال کردن pruning  دو قسمت اول که شامل قسمت های فضاگیر است دیگر دانلود نمی شود و فقط اطلاعات 3 و 4 هر بلوک دانلود می شوند.
ولی بیت کوین کور نمی تواند بدون داشتن اطلاعات کامل آخرین بلوک ها کار کند برای همین حداقل 288 بلوک آخر را در این مد به طور کامل دانلود می کند .
فضای مورد نیاز برای دانلود اطلاعات raw blocks و undo data از 288 بلوک 550 مگا بایت می باشد برای همین در فایل تنظیمات باید عددی بزرگتر از 550 را در مقابل prune نوشت .
بزرگتر کردن این عدد به معنای اجازه ی داشتن اطلاعات کامل بلوک های بیشتری است.
توضیحات مختصری نیز در هنگام اجرای -help در محیط cmd در باره ی pruning نشان داده می شود.
 
شکل 6-10 توضیحات prune در cmd
در صورت فعال بودن قابلیت pruning   هنگامی که یک بلوک جدید تشکیل می شود ،
اطلاعات نوع اول و دوم از قدیمی ترین بلوکِ کاملِ دانلود شده خودکار حذف می شود و اطلاعات کامل بلوک جدید دانلود می شود.
برای ارتباط json rpc باید تنظیمات خاصی انجام دهید . گزینه های RPC server options که در انتهای اجرای -help در cmd می آیند از این جمله اند .
مانند وارد شدن به یک حساب به username و  password نیاز است . می تواند هر چیز دلخواهی باشد . تنظیم آن ها با دستور های زیر خواهد بود همچنین راهنمایی که در bitcoind  ظاهر می شود نیز موجود است .
-rpcuser=<user>
Username for JSON-RPC connections
-rpcpassword=<pw>
Password for JSON-RPC connections
برای دسترسی به چیزی در اینترنت به آدرس و پورت نیاز است . دستور تنظیم آن به صورت زیر است . البته به صور پیشفرض دارای مقدار است .
-rpcbind=<addr>[:port]
Bind to given address to listen for JSON-RPC connections. Do not expose
the RPC server to untrusted networks such as the public internet!
This option is ignored unless -rpcallowip is also passed. Port is
optional and overrides -rpcport. Use [host]:port notation for
IPv6. This option can be specified multiple times (default:
127.0.0.1 and ::1 i.e., localhost)
هر ip نمی تواند به بیت کوین کور محلی شما دسترسی پیدا کند . شما باید ip خود را با دستور زیر اضافه کنید .
-rpcallowip=<ip>
Allow JSON-RPC connections from specified source. Valid for <ip> are a
single IP (e.g. 1.2.3.4), a network/netmask (e.g.
1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This
option can be specified multiple times
البته تنظیمات بیشتری هم موجود است اما به علت کافی بودن تنظیمات بالا آورده نمی شود.
3-6 تفاوت تراکنش coinbase با غیر coinbase
قبلا گفته بودیم یک تراکنش خام به صورت زیر است  که حاوی input  ها و output  های تراکنش است . محاسبه ی  هش آن منجر به تولید txid می شود که در انتها در merkle tree استفاده می شد.
 
شکل 6-11 اجزای یک تراکنش خام
ولی جایزه ی بیت کوین از هیچ کیف پولی وارد کیف پول برنده نمی شود به همین علت حاوی output نیست .
و یادتان هست که اولین تراکنش موجود برای تشکیل merkle root و در فرآیند merkle tree تراکنش  coinbase است .
Input برای یک تراکنش غیر coinbase به صورت زیر است .
 
شکل 6-12 اجزای input  غیر Coinbase
Coinbase input  به صورت زیر است.

 
شکل 6-12 اجزای input  Coinbase
که از آن یک raw transaction  ساخته خواهد شد.
تفاوت آن آشکار است که قسمت output به null تبدیل شده (نسبت به یک تراکنش معمولی ) و دو قسمت مهم اضافی دارد . یکی height و دیگری Coinbase script .
ناکاماتو تا اکنون طبق bip  های 34  و 65 و 66 و 90  ، چهار نسخه بلوک هدر معرفی کرده که هر کدام هم دارای soft fork و هم دارای hard fork هستند . hard fork آن به صورت یک حد شماره بلوک مشخص تعیین شده . 
شکل 6-13 قسمتی از bip-90
تصویر بالا از روی bip 90  برداشت شده و حداکثر ارتفاع بلوک برای نسخه های بلوک هدر را تعیین کرده است .
همچنین حاوی قوانین soft fork  می باشد.
در نسخه اول بلوک هدر قسمت height در Coinbase input وجود نداشت و در نسخه 2 این قسمت اضافه شد و این قسمت در نسخه 1 جزو Coinbase script بود.
قبلا گفته بودیم در صورت امتحان تمام nonce ها باید یک merkle root  جدید اضافه کرد.
و یکی از راه ها تغییر همین Coinbase script  است . این قسمت یک اطلاعات دلخواه است برای تشکیل یک  merkle root جدید.
یکی از توسعه دهنگان بیت کوین برنامه ای به زبان پایتون تولید کرده برای ارتباط با بلاکچین به نام python blkmaker .
در این برنامه تابعی برای دریافت اطلاعات مورد نیاز برای ساخت بلوک هدر و تابعی برای ساخت coinbase txid و تابعی برای ارسال اطلاعات هش شده وجود دارد.
4-6 کلیات پروژه
هدف از انجام این پروژه ساخت یک زیربنا برای ساخت یک ماینر بر اساس FPGA است . زیربنای ساخت یک ماینر همان هش sha256 است.
در ابتدا توضیحاتی در باره ی الگوریتم داده می شود سپس برنامه ی sha256.vhd و شبیه سازی آن در ادامه می آید . برنامه ی topsha.vhd که کد sha256.vhd را به عنوان زیر برنامه استفاده کرده برای قرار دادن 32 بیت اطلاعات در هر دوره ی محاسبه است همچنین مقایسه با target انجام شده که بیت های مربوط به عملیات ماینینگ را کنترل می کند و در نهایت  شبیه سازی با اطلاعات یک بلوک هش شده انجام می شود.
5-6 هش  sha256
هش  یک رمزنگاری  است غیر قابل cryptanalyze است . به این علت که در فرآیند هش به واسطه ی عملیات های شیفت و جمع ، مقداری از اطلاعات از بین می روند .
همچنین تفاوت هش با رمزنگاری های دیگر در وجود یک خروجی با سایز ثابت است.
برتری یک رمزنگاری نسبت به یک رمزنگاری دیگر در داشتن یک خروجی متفاوت در صورت داشتن یک ورودی متفاوت است.
Sha مخفف secure hash algorithm است و همانطور که از نامش پیداست از خانواده ی هش  می باشد.
پدربزرگ sha  ها هش sha_1 است که بعضا توانسته اند نقطه ضعف هایی برای آن پیدا کنند.
مثلا با دو ورودی متفاوت توانسته اند به خروجی یکسان برسند . اگرچه به تعداد انگشت شمار.
خانواده ی دیگری به نام sha_2  نیز هستند که از خانواده ی آن ها می توان به
Sha-256  و sha-224 و  sha-512 می توان نام برد .
جدیداً نیز sha-3 ارائه شده است.
الگوریتم این هش ها را می توان در آدرس
http://dx.doi.org/10.6028/NIST.FIPS.180-4 جستوجو کرد.
عدد آخر این هش ها نشانه ی سایز خروجی آن ها به بیت می باشد.
Sha-256  دارای یک ورودی به اندازه ی حداکثر 2 64  بایت (تقریبا می توان گفت محدودیت ورودی ندارد) و یک خروجی با سایز 256 بیت است .
ورودی شامل قسمت اطلاعات اصلی و یک عدد 1  در انتها و در ادامه تعدادی صفر به عنوان padding و 64 بیت انتهایی برای نشان دادن تعداد بایت ورودی است.
باید به این توجه شود که بلوک هدر دارای 512 بیت است.
نحوه ی padding به این صورت است : اگر l طول اطلاعات به بیت باشد یک 1 به آن می پیوندد. که می شود l+1 . اکنون تعدادی صفر در ادامه قرار می دهیم در محل اطلاعات کم ارزش. فرض کنید k صفر در ادامه قرار گرفته . قرار دادن صفر تا جایی جلو می رود که باقی مانده ی l+1+k به 512 عدد 64 باشد.
در ادامه نیز همانطور که قبلا گفته شد سایز اطلاعات یعنی همان عدد l که به بایت تبدیل شده می آید.
به این صورت به همراه padding و سایز  اطلاعاتی که برای شروع عملیات مورد نیاز است به صورت ضریبی از 512 در می آید.
برای انجام عملیات هش در پروسه ی ماینینگ به این علت که سایز بلوک هدر 512 بیت است در سمت راست بلوک هدر یک عدد یک می گذاریم و در ادامه 447 صفر و
0x00000280 برای سایز می گذاریم.
به این صورت 1024 بیت اطلاعات ورودی برای هش به دست می آید.
در ابتدا 512 بیت پر ارزش را بر می داریم و به 16 گروه 32 بیتی تقسیم می کنیم.
اگر M گروه اول 512 بیتی ( همان 512 بیت پرارزش ) باشد داریم :
 
شکل 6-14 قسمت کردن ورودی به 16 قسمت 32 بیتی
W ها همان اطلاعات  های 32 بیتی خواهند بود.
 
شکل 6-15 توابع الگوریتم sha256
توابع بالا در الگوریتم هش کاربرد دارند.
توضیح نماد ها به صورت زیر است :

 

 
شکل 6-16 توضیح نماد های استفاده شده
در انجام محاسبات 64 عدد ثابت نیاز به مقادیر زیر هست. در عملیات هش آن ها به عنوان k i  شناخته می شوند :
 
شکل 6-17 ثابت های مورد نیاز برای محاسبه ی هش
 
شکل 6-18 محاسبه ی w ها در هر دور محاسبه از 64 دور
قبلا داشتیم که M از concatenate  کردن W  ها به دست می آمد. یعنی w 1  تا w 16  از خود ورودی و مابقی از تابع بالا به دست می آید .
ابتدا h  ها ی با بالانویس 0 که مقادیر ثابتی هستند  که هش خروجی در انتها در آن ها خواهد بود را مقدار اولیه می دهیم :
 
شکل 6-19 مقادیر H با بالا نویس صفر
ابتدا a,b,c,d,e,f,g,h را مقدار دهی اولیه می کنیم:
 
شکل 6-20 مقدار دهی اولیه
ما در عملیات هش برای ماینینگ دو اطلاعات  512 بیتی با پدینگ و سایز به دست آوردیم . یعنی دو سری عملیات هش نیاز است که انجام دهیم برای هر کدام از 512 بیت ها . ابتدا از 512 بیت پر ارزش شروع می کنیم و در ابتدا t=1 است . برای 512 بیت دوم t=2 می شود .
به h  های مقدار اولیه داده شده با بالا نویس صفر توجه کنید .
همچنین به تصویر زیر آن توجه کنید . برای مقدار اولیه دادن به a,b,c,d,e,f,g,h برای t=1 باید h های با بالا نویس 0 را استفاده کنیم.
سپس عملیات زیر برای i های 1 تا 64 :
 
شکل 6-21 عملیات در هر دور

سپس :
 
شکل 6-22 محاسبه خروجی در آخرین مرحله بعد از 64 دور
برای 512 بیت دوم با توجه به این که t=2 می شود باید خروجی هش 512 بیت اول را که  h  با بالا نویس 1 هستند را به a,b,c,d,e,f,g,h مقدار اولیه دهی کرد.
یعنی شکل 6-20 سپس عملیات شکل 6-21 و سپس عملیات شکل 6-22 انجام می شود.
یعنی دو دور عملیات یکسانی را انجام دادیم با مقادیر اولیه ی متفاوت و در آخر هر دور a,b,c,d,f,g,h های به دست آمده را با h های با بالا نویس کمتر جمع کردیم تا h  ها به روزرسانی  شوند و h ها با بالا نویس بالاتر به دست بیایند.
در عملیات ماینینگ h ها با بالا نویس 2 جواب نهایی خواهد بود .
باید توجه کرد که اگر اطلاعات ورودی هش از 448 بیت کمتر بود نیازی به دو دور انجام محاسبات نبود ولی به علت 512 بیتی بودن اطلاعات بلوک هدر مجبور به انجام دو دور محاسبه برای به دست آوردن sha-256 شدیم .
اگر اطلاعات ورودی از (512*2)-64 یعنی 960  بیت هم بالا بزند مجبور به محاسبه ی سه دور محاسبه برای به دست آوردن sha-256 می شدیم.
6-6 پیاده سازی به زبان  VHDL
محیط VIVADO در ذیل قابل مشاهده است .
 
شکل 6-23 محیط vivado
پروژه یک SHA-256 ساده است که از سه کتابخانه استفاده می کند .
1.	Types
2.	Constants
3.	Functions
و یک برنامه ی top دارد که عملیات اصلی در آن انجام می شود.
ابتدا از توضیح کتابخانه ها شروع می کنیم .
7-6 کتابخانه ی types

library ieee;
use ieee.std_logic_1164.all;
package sha256_types is
-- Type for storing the expanded message blocks, W_j:
type expanded_message_block_array is array(0 to 63) of std_logic_vector(31 downto 0);
-- Type for storing the constant array, K_j:
type constant_array is array(0 to 63) of std_logic_vector(31 downto 0);
type state_type is (IDLE, BUSY, FINAL);
end package;
در کد بالا  expanded_message_block_array برای ثبت w iهاست . در هر دور w ها محاسبه می شوند و در این آرایه ریخته می شوند تا در مراحل بعدی از 64 دور استفاده شوند .
قبلا گفته بودیم 	یعنی برای انجام عملیات i ام  با توجه به شکل 6-21  به صورت زیر به w های مراحل قبلی نیاز داریم.
constant_array : برای ریختن مقادیر ثابت k i استفاده می شود.
state_type : برای تعیین حالت پروسه ی هشینگ
8-6 کتابخانه ی constants
library ieee;
use ieee.std_logic_1164.all;
use work.sha256_types.all;
package sha256_constants is
-- Initial intermediate hash values:
constant INITIAL_A : std_logic_vector(31 downto 0) := x"6a09e667";
constant INITIAL_B : std_logic_vector(31 downto 0) := x"bb67ae85";
constant INITIAL_C : std_logic_vector(31 downto 0) := x"3c6ef372";
constant INITIAL_D : std_logic_vector(31 downto 0) := x"a54ff53a";
constant INITIAL_E : std_logic_vector(31 downto 0) := x"510e527f";
constant INITIAL_F : std_logic_vector(31 downto 0) := x"9b05688c";
constant INITIAL_G : std_logic_vector(31 downto 0) := x"1f83d9ab";
constant INITIAL_H : std_logic_vector(31 downto 0) := x"5be0cd19";

-- Array of constants used in the algorithm:
constant constants : constant_array := (
x"428a2f98", x"71374491", x"b5c0fbcf", x"e9b5dba5", x"3956c25b", x"59f111f1", x"923f82a4", x"ab1c5ed5",
x"d807aa98", x"12835b01", x"243185be", x"550c7dc3", x"72be5d74", x"80deb1fe", x"9bdc06a7", x"c19bf174",
x"e49b69c1", x"efbe4786", x"0fc19dc6", x"240ca1cc", x"2de92c6f", x"4a7484aa", x"5cb0a9dc", x"76f988da",
x"983e5152", x"a831c66d", x"b00327c8", x"bf597fc7", x"c6e00bf3", x"d5a79147", x"06ca6351", x"14292967",
x"27b70a85", x"2e1b2138", x"4d2c6dfc", x"53380d13", x"650a7354", x"766a0abb", x"81c2c92e", x"92722c85",
x"a2bfe8a1", x"a81a664b", x"c24b8b70", x"c76c51a3", x"d192e819", x"d6990624", x"f40e3585", x"106aa070",
x"19a4c116", x"1e376c08", x"2748774c", x"34b0bcb5", x"391c0cb3", x"4ed8aa4a", x"5b9cca4f", x"682e6ff3",
x"748f82ee", x"78a5636f", x"84c87814", x"8cc70208", x"90befffa", x"a4506ceb", x"bef9a3f7", x"c67178f2"
);
-- TODO: Store in block ROM

end package;
مقادیر ثابت ki و H های با بالانویس 0 تعریف شده اند .
9-6 کتابخانه ی function
اگر به شکل 6-15 توجه کنید در کتابخانه ی library این توابع عینا تعریف شده :
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.sha256_types.all;
use work.sha256_constants.all;
package sha256_functions is
-- Function used to index arrays using std_logic_vector:
function index(input : in std_logic_vector) return integer;
-- Resets the intermediate hash values to their initial values:
procedure reset_intermediate(signal a, b, c, d, e, f, g, h : out std_logic_vector);
-- Calculates the j'th word of the message schedule:
function schedule(constant input : in std_logic_vector(31 downto 0);
constant W : in expanded_message_block_array;
constant iteration : in std_logic_vector(5 downto 0))
return std_logic_vector;
-- The SHA256 compression function for iteration j:
procedure compress(
-- Intermediate hash values from the previous iteration:
signal h0, h1, h2, h3, h4, h5, h6, h7 : inout std_logic_vector(31 downto 0);
-- The expanded message block value for this iteration:
constant W : in std_logic_vector(31 downto 0);
constant K : in std_logic_vector(31 downto 0));
-- Random mathematical functions used in SHA256:
function Ch(x, y, z : std_logic_vector) return std_logic_vector;
function Maj(x, y, z : std_logic_vector) return std_logic_vector;
-- Big sigma functions, using S because of lacking Unicode support:
function s0(x : std_logic_vector) return std_logic_vector;
function s1(x : std_logic_vector) return std_logic_vector;
-- Small sigma functions; using o which looks fairly similar:
function o0(x : std_logic_vector) return std_logic_vector;
function o1(x : std_logic_vector) return std_logic_vector;
end package sha256_functions;
همچنین اگر به شکل 6-21 توجه کنید همین عملیات در procedure  به نام compress تعریف شده :
procedure compress(
-- Intermediate hash values from the previous iteration:
signal h0, h1, h2, h3, h4, h5, h6, h7 : inout std_logic_vector(31 downto 0);
-- The expanded message block value for this iteration:
constant W : in std_logic_vector(31 downto 0);
-- The constant for this iteration:
constant K : in std_logic_vector(31 downto 0))
is
variable t1, t2 : std_logic_vector(31 downto 0);
variable a, b, c, d, e, f, g, h : std_logic_vector(31 downto 0);
begin
-- Assign intermediate hash values to working variables:
a := h0;
b := h1;
c := h2;
d := h3;
e := h4;
f := h5;
g := h6;
h := h7;

-- Calculate temporary values:
t1 := std_logic_vector(unsigned(h) + unsigned(s1(e))+ unsigned(Ch(e, f, g)) + unsigned(K) + unsigned(W));
t2 := std_logic_vector(unsigned(s0(a)) + unsigned(Maj(a, b, c)));
-- Assign new values to working variables:
h := g;
g := f;
f := e;
e := std_logic_vector(unsigned(d) + unsigned(t1));
d := c;
c := b;
b := a;
a := std_logic_vector(unsigned(t1) + unsigned(t2));

-- Assign new values to the intermediate hash values:
h0 <= a;
h1 <= b;
h2 <= c;
h3 <= d;
h4 <= e;
h5 <= f;
h6 <= g;
h7 <= h;
end procedure compress;
از 64 دور عملیات یکی را انجام میدهد با ورودی های wi و ki و خروجی مرحله قبل و در انتها خروجی جدید می سازد .
محاسبه ی wi ها نیز در تابع schedule انجام می شود.
function schedule(constant input : in std_logic_vector(31 downto 0);
constant W : in expanded_message_block_array;
constant iteration : in std_logic_vector(5 downto 0))
return std_logic_vector
is
variable j : integer := index(iteration);
begin
if j < 16 then -- If j < 16 then W_j = M_j
return input;
else -- Else, W_j = o1(W_j-2) + W_j-7 + o0(W_j-15) + W_j-16
return std_logic_vector(unsigned(o1(W(j - 2))) +
unsigned(W(j - 7)) + unsigned(o0(W(j - 15))) + unsigned(W(j - 16)));
end if;
end function schedule;
فرض کنید می خواهید عملیات هش را دوباره شروع کنید .
نیاز دارید H ها با بالا نویس 0 مقداردهی اولیه شوند. این کار در تابع reset_intermediate انجام می شود.
procedure reset_intermediate(signal a, b, c, d, e, f, g, h : out std_logic_vector) is
begin
a <= INITIAL_A;
b <= INITIAL_B;
c <= INITIAL_C;
d <= INITIAL_D;
e <= INITIAL_E;
f <= INITIAL_F;
g <= INITIAL_G;
h <= INITIAL_H;
end procedure reset_intermediate;
10-6Sha256.vhd 
اکنون به کد اصلی میرویم جایی که از این سه کتابخانه استفاده می کنیم.
نام فایل sha256.vhd است.
ابتدا اصل برنامه بعد از begin مربوط به process مورد بررسی قرار می گیرد.
if reset = '1' then
reset_intermediate(h0, h1, h2, h3, h4, h5, h6, h7);
current_iteration <= (others => '0');
state <= IDLE;
Reset یک port  ورودی است . یعنی می توان این برنامه را component کرد و از یک برنامه ی top آن را کنترل کرد .
Reset بر پالس ساعت اولویت داده شده و گفته شده اگر یک شود h ها با بالانویس صفر مقدار دهی شوند . یعنی قبل از شروع دوره ی یک هش باید reset 1 بشود و حالت در وضعیت اولیه قرار می گیرد.
سپس عملیات همراه با پالس ساعت شروع می شود.
elsif rising_edge(clk) and enable = '1' then
در زیر حالت idle نشان داده می شود.
بعد از انجام ریست بایست update  1 شود تا به وضعیت بعدی منتقل شویم.
بعد از یک پالس ساعت باید update را 0 کرد تا در صورت رسیدن به انتهای 64 دور که دوباره به این وضعیت بازگشت انجام می شود بدون آپدیت 512  بیت دوم از 1024 بیت، وضعیت به busy تغییر نکند.
Update  را نیز می توان از برنامه ی top  کنترل کرد.
case state is
when IDLE =>
-- If new data is available, start hashing it:
if update = '1' then
a <= h0;
b <= h1;
c <= h2;
d <= h3;
e <= h4;
f <= h5;
g <= h6;
h <= h7;
current_iteration <= (others => '0');
state <= BUSY;
end if;
در زیر وضعیت busy  می باشد که به اندازه ی 64 پالس ساعت به طول می انجامد.
در آن عملیات 64 دوره ای برای هر 512 بیت انجام می شود. در صورت اتمام 64 دوره وضعیت به final تغییر می کند.
when BUSY =>
-- Load a word of data and store it into the expanded message schedule:
W(index(current_iteration)) <= schedule(word_input, W, current_iteration);

-- Run an interation of the compression function:
compress(a, b, c, d, e, f, g, h,
schedule(word_input, W, current_iteration),constants(index(current_iteration)));
if current_iteration = b"111111" then
state <= FINAL;
else
current_iteration <= std_logic_vector(unsigned(current_iteration) + 1);
end if;
اگر به شکل 6-22 بازگردیم ، در زیر عملیات آپدیت هش انجام می شود که مرحله ی آخر هش داشتیم. که در زیر دوباره آمده .
when FINAL =>
h0 <= std_logic_vector(unsigned(a) + unsigned(h0));
h1 <= std_logic_vector(unsigned(b) + unsigned(h1));
h2 <= std_logic_vector(unsigned(c) + unsigned(h2));
h3 <= std_logic_vector(unsigned(d) + unsigned(h3));
h4 <= std_logic_vector(unsigned(e) + unsigned(h4));
h5 <= std_logic_vector(unsigned(f) + unsigned(h5));
h6 <= std_logic_vector(unsigned(g) + unsigned(h6));
h7 <= std_logic_vector(unsigned(h) + unsigned(h7));
state <= IDLE;
end case;

اکنون به بررسی کد بعد از begin  مربوط به architecture  و بعد از begin مربوط به process  می پردازیم.
word_address <= current_iteration(3 downto 0)
when (current_iteration and b"110000") = b"000000"
else (others => '0');
hash_output <= h0 & h1 & h2 & h3 & h4 & h5 & h6 & h7;
ready <= '1' when state = IDLE else '0';
state_s<= state;
hasher: process(clk, reset, enable)
begin
Word_address یک پورت خروجی 4 بیتی است که مشخص می کند اکنون کدام 32 بیت از ورودی روی word_input که 32 بیتی و یک پورت داخلی است قرار بگیرد.
11-6 انجام شبیه سازی
در شبیه سازی یک برنامه در زیر شبیه سازی اصلی قرار دارد که testrom  نام دارد. در این برنامه یک سری ثابت تعریف شده برای   دادن ورودی به word_input است.
architecture behaviour of testrom2 is
type testdata2_array is array(0 to 31) of std_logic_vector(31 downto 0);
constant testdata2 : testdata2_array := (
x"0000c020", x"02ecc740", x"15a1b0be", x"c622fba2", x"c05dd848", x"4793e499", x"64991900", x"00000000",
x"00000000", x"7dd2ee24", x"71dd9802", x"3675d775", x"97dc1573", x"5f91c846", x"5e2c1b34", x"11716d72",
x"f41f9ac6", x"B3A8455D", x"083a1f17", x"5d2c4300", x"80000000", x"00000000", x"00000000", x"00000000",
x"00000000", x"00000000", x"00000000", x"00000000", x"00000000", x"00000000", x"00000000", x"00000280");
begin
readproc: process(clk)
begin
if falling_edge(clk) then -- FIXME
if word_address(5 downto 4) = b"00" then -- Test set 1, "abc"
if word_address = b"000000" then
word_output <= x"61626380"; -- "abc" and a 1 bit at the end
elsif word_address = b"001111" then
word_output <= x"00000018"; -- message length is 24 bits
else
word_output <= (others => '0');
end if;
else -- Test set 2, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
if word_address(5) = '1' then
word_output <= testdata2(16 + to_integer(unsigned(word_address(3 downto 0))));
else
word_output <= testdata2(to_integer(unsigned(word_address(3 downto 0))));
end if;
end if;
end if;
end process readproc;

end architecture behaviour;

گفته شده اگر 2 بیت پر ارزش آدرس 0b00 بود اطلاعات اول و در صورتی که 0b01 بود قسمت اول از اطلاعات دوم یعنی  testdata2 و اگر 0b11 یا 0b10 بود قسمت دوم از اطلاعات دوم بر روی تست اطلاعات قرار بگیرد . این به آن علت است که اطلاعات اول تنها 24 بیت ولی اطلاعات دوم 512 بیت است.
من در محل اطلاعات دوم یک بلوک هدر که 512 بیتی است گذاشته ام پس از آن 0x800000 گذاشته ام که اگر به باینری تبدیل شود همان عدد 1 هست در ادامه ی اطلاعات اصلی و در ادامه 0 به عنوان پدینگ و 0x000280 برای اینکه بگوییم اطلاعات 512 بیتی است گذاشته ام.
البته در ماینینگ ، قسمت nonce  می بایست تغییر کند و هش شود ولی اینجا یک اطلاعات 512 بیتی برای امتحان قرار داده شده.
اطلاعات اول یک رشته است به صورت “abc” که کمتر از 448 بیت است پس فقط یک دور 64 تایی عملیات نیاز دارد .
ولی یک بلوک هدر که اطلاعات دوم است همانطور که گفتم به دو دور 64 تایی عملیات نیاز دارد برای همین به دو قسمت 512 تایی تبدیل شده و هر بار یکی را وارد می کنیم و در میانه ی کار reset را 1 نمی کنیم . و تنها update  را 0 و 1 می کنیم.
این عملیات بر روی update  و reset و بیت های پر ارزش address در برنامه ی شبیه سازی اصلی آمده که مشاهده خواهیم کرد .
ابتدا اطلاعات وارده را بر روی یک هش کننده ی  آنلاین امتحان می کنیم به آدرس :
https://www.fileformat.info/tool/hash.htm
 
شکل 6-24 سایت محاسبه گر هش

و جواب آن :
 
شکل 6-25 هش محاسبه شده
در صورتی که در قسمت hex هم این داده را قرار دهیم به همین جواب می رسیم :
 
شکل 6-26 محاسبه هش با ورودی هگزادسیمال
12-6 برنامه شبیه سازی sha256.vhd
در زیر سیگنال های مورد نیاز برای کنترل sha256.vhd و همچنین بعضی سیگنال ها برای عیب یابی تعریف شده اند .
سیگنال های عیب یابی برای بررسی و رفع مشکل هشر در برنامه ی top استفاده می شود.
در زیر، پالس ساعت مورد نیاز تولید شده و دو زیر برنامه ی rom  و sha256 ، port map شده اند.
uut: entity work.sha256
port map(
clk => clk,
enable=>enable,
reset => reset,
ready => ready,
update => update,
word_address => word_address,
word_input => word_input,
hash_output => hash_output,
debug_port => debug_port,
state_s => state_s);
testdata_address(3 downto 0) <= word_address;
testdata: entity work.testrom2
port map(
clk => clk,
word_address => testdata_address,
word_output => word_input);
enable<='1';
clock: process
begin
clk <= '0';
wait for clk_period / 2;
clk <= '1';
wait for clk_period / 2;
end process clock;
در زیر دو بیت پر ارزش آدرس را 0b00  قرار داده تا اطلاعات اول بر روی خط قرار بگیرد . همچنین یک بار reset اتفاق افتاده و صبر کرده تا ready=1 شود .
سپس update=1  شده تا عملیات شروع شود . (نیازی نیست 1 بماند برای همین بعد از یک پالس ساعت آن را صفر کرده )
و سپس گفته اگر خروجی با مقدار مورد نظر ما تفاوت داشت یک error  ثبت کن .
update <= '0';
testdata_address(5 downto 4) <= b"00";
wait for clk_period * 2;
-- Reset the module:
reset <= '1';
wait for clk_period;
reset <= '0';
wait for clk_period;
-- The module should now be ready for work:
assert ready = '1' report "Module is not ready after reset!";
wait for clk_period;
-- Start hashing the first test data:
update <= '1';
wait for clk_period;
update <= '0';
wait until ready = '1';
assert hash_output = x"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
report "Hash of 'abc' is not ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad!";
wait for clk_period;
همانطور که می خواستیم  نتیجه با جواب در سایت یکسان در آمده است.
همین عملیات برای اطلاعات دوم انجام شده .
با این تفاوت که در ابتدا بیت 4 آدرس برای قرار دادن قسمت اول اطلاعات دوم 1 شده و سپس بیت 5 برای قسمت دوم اطلاعات دوم و سپس میانه ی کار update  یک بار 1 و سپس صفر شده .
نتیجه ی شبیه سازی را در زیر می بینید .
فلش های قرمز زمان بازنشانی به مقادیر اولیه را نشان می دهد .
فلش آبی محل به روزرسانی خروجی که همان خروجی هش است را نشان می دهد.
فلش های زرد خروجی هش را نشان می دهد که با سایت منطبق است .

 
شکل 6-27 نتیجه ی شبیه سازی SHA256.VHD

برای یک اطلاعات 512 بایتی هم به شکل زیر اگر توجه کنید تنها در قسمت فلش زرد بازنشانی صورت گرفته دیگر بازنشانی مقدار اولیه در میانه ی کار صورت نگرفته و خروجی مرحله ی قبل به عنوان H با بالا نویس 0 قرار گرفته با فلش نیلی و جواب نهایی با فلش زرد نشان داده شده که منطبق سایت است.

 
شکل 6-27 ادامه نتیجه ی شبیه سازی SHA256.VHD

13-6 برنامه ی top_sha
واضح است ک برای انجام عملیات ماینیگ یک برنامه ی مدیرت لازم است تا اطلاعات مورد نیاز گرفته شده از pc را به موقع بر روی خط قرار دهد.
این برنامه در ادامه توضیح داده می شود.
یادآوری یک موضوع شاید خالی از لطف نباشد که در عملیات ماینینگ خروجی هش بلوک هدر دوباره از هش باید رد شود و سپس با target  مقایسه شود.
این موضوع نباید با عملیات اصلی هش که چون بلوک هدر بیش از 448 بیت است باید دو دور 64 تایی عملیات انجام شود اشتباه گرفت.
آن عملیات اصلی هش بود و جزو الگوریتم هش .
ولی این قوانین ماینینگ است .
در عملیات اصلی هش ما بعد از دور اول 64 تایی، h  ها با بالانویس 0 را بازنشانی نمی کنیم و دور دوم را ادامه می دهیم و هش بلوک هدر را محاسبه می کنیم . (الگوریتم)
در طی این عملیات برای 512 بیت اطلاعات تنها یکبار بازنشانی h و یک بار پدینگ و سایز انجام دادیم .
پس از اتمام دور دوم 64 تایی یک خروجی 256 بیتی داریم که دوباره آن را از هش رد می کنیم .
یعنی h ها را بازنشانی می کنیم و پدینگ و سایز را انجام می دهیم و چون اطلاعات ورودی که خروجی هش قبلی است  از 448 بیت کمتر است ، تنها یک دور 64 تایی عملیات انجام می دهیم.
شاید یک مثال برای تقریب ذهن خوب باشد .
version :20c00000
prehash:00000000000000000019996499e4934748d85dc0a2fb22c6beb0a11540c7ec02
merkle :c69a1ff4726d7111341b2c5e46c8915f7315dc9775d775360298dd7124eed27d
time :5D45A8B3
bits :171f3a08
nonce : 0b432c5d
resalt:00000000000000000014396caadc23e94b5dfa2b29bc25f01969cc13572e8048
در بالا اطلاعات یک بلوک هدر موفقیت آمیز به همراه nonce موفقیت آمیز آن موجود است که از سایت blockchain.info  به دست آمده است.
همچنین حاصل عبور دوبار از هش که تعدادی صفر در ابتدای آن موجود است دیده می شود
برای تشکیل بلوک هدر باید آن ها را به little endian  تبدیل کرد سپس دو بار از هش رد کرد .
حاصل little endian  شده ی آن به صورت زیر است :
0000c02002ecc74015a1b0bec622fba2c05dd8484793e4996499190000000000000000007dd2ee2471dd98023675d77597dc15735f91c8465e2c1b3411716d72f41f9ac6B3A8455D083a1f175d2c430b
در سایت محاسبه گر یک بار از هش عبور می دهیم حاصل زیر به دست می آید :
40a19f20387e9fd87bd4c21a654618529c01f1e0499dfd3d4e67646e11d74fad
اگر حاصل بالا را دوباره از هش عبور دهیم حاصل زیر را می بینیم :
48802e5713cc6919f025bc292bfa5d4be923dcaa6c3914000000000000000000
که اگر آن را به فرمت big endian  در بیاوریم همان result  تصویر بالا به دست می آید .
در کد زیر  حالت های  round 1 و round 2 برای محاسبه ی هش بلوک هدر وround 3 برای محاسبه ی هشِ هشِ بلوک هدر است .
if ( enable ='0') then--falling edg because hasher is happening in rising so data must be in hasher half clock befor rising
reset_sha <='1';
state <= reset_s;
nonce <=nonce_offset;
elsif( next_block ='1') then
--nonce <= nonce_offset ; behtr ast dar inja meghdar dehi nashavad chon momken ast hanooz nonce_offset update nashode bashad
state <= reset_s ;
i_got_next <= '1';
got_next <='1';
reset_sha<='1';--sha256 reset mishavad
elsif(falling_edge(clk) and next_block ='0') then
if(got_next = '1' ) then --and next_block ='0') then
i_got_next <= '0';
got_next   <= '0';
nores      <= '0';
vict       <= '0';
nonce      <= nonce_offset ;
end if;
در بالا enable  و next_block بر پالس ساعت اولویت داده شده اند.
Enable برای راه اندازی برنامه ی زیرین که sha_256 است استفاده می شود و در پورت ورودی قرار دارد.
Next_block متعلق به زمانی است که فردی دیگر توانسته به جواب دست پیدا کند و ما باید تمام مقادیر خود را بازنشانی کنیم و از ابتدا شروع کنیم . یک کردن این بیت عملیات ماینیگ را متوقف می کند . این بیت یک پورت ورودی است که از برنامه ای بالاتر کنترل می شود.
سپس برنامه ی قرار دادن اطلاعات بر روی خط با پالس ساعت آغاز می شود.
در زیر حالت reset_s  و round_1 را می بینید.
Update انجام شده و اطلاعات 512 تای اول روی خط قرار می گیرد.
case state is
when reset_s =>
reset_sha<='0';
if(ready_sha = '1') then--in shart hamishe bargharare va gozashtanesh bi morede
update_sha<='1';
state <= round_1;
temp_merkle   := merkle;
temp_pre_hash := pre_hash;
end if;
when round_1 =>
update_sha<='0';
if (address ="0000")then
word_input_sha <= version;
elsif (address(3) = '0') then
word_input_sha <= temp_pre_hash(255 downto 224 );
temp_pre_hash := std_logic_vector(shift_left(unsigned(temp_pre_hash),32));
elsif (address ="1000")then
word_input_sha <= pre_hash(31 downto 0);
else
word_input_sha <= temp_merkle(255 downto 224 );
temp_merkle := std_logic_vector(shift_left(unsigned(temp_merkle),32));
end if;
if(ready_sha = '1') then
state <= round_2;
update_sha <= '1';
end if;
در زیر نیز round_2 که 512 تای دوم را محاسبه می کند می بینید.
when round_2 =>
update_sha<='0';
if    (address = "0000") then
word_input_sha <= merkle(31 downto 0);
elsif (address = "0001") then
word_input_sha <= unix_time;
elsif (address ="0010") then
word_input_sha <=nbits;

elsif (address ="0011") then

word_input_sha <=nonce;

elsif (address ="0100") then
word_input_sha <= x"80000000";
elsif(address ="1111") then
word_input_sha <= f_r_size;
else
word_input_sha <= x"00000000";
end if;
if(ready_sha = '1') then
state <= wait_1;
update_sha <= '1';
reset_sha <= '1';
temp_output := hash_output;
end if;

در زیر نیز حالت wait برای بازنشانی h ها با بالا نویس 0 یعنی همان ریست کردن زیر برنامه انجام می شود تا برای محاسبه ی هش هش آماده شود. سپس round_3 شروع می شود.
when wait_1 =>
reset_sha <= '0';
state <= round_3;
when round_3 =>
reset_sha <= '0';
update_sha<='0';
if (address(3) = '0') then
word_input_sha <= temp_output(255 downto 224);
temp_output := std_logic_vector(shift_left(unsigned(temp_output),32));
elsif (address ="1000") then
word_input_sha <= x"80000000";
elsif(address ="1111") then
word_input_sha <= t_r_size;
else
word_input_sha <= x"00000000";
end if;
if(ready_sha = '1' ) then
state <= compare;
--update_sha <= '1';
end if;

در زیر وارد حالت compare می شویم . که خروجی را با target مقایسه می کند.
در صورت کوچکتر بودن جواب از target ،بیت victory یک می شود به معنای رسیدن به جواب است در غیر این صورت، رسیدن به انتهای nonce ، بیت nores را که به معنای بدون نتیجه است را یک می کند که در این صورت در برنامه ی بالا دست که بعدا توضیح داده می شود باید به pc در خواست یک merkle جدید بدهیم .
در غیر این صورت nonce  یکی اضافه شده و عملیات ادامه می یابد.
when compare =>
temp_hash := hash_output;
for i in 0 to 31 loop
temp_hash_c := std_logic_vector(shift_left(unsigned(temp_hash_c),8));
temp_hash_c(7 downto 0) := temp_hash(7 downto 0);
temp_hash := std_logic_vector(shift_right(unsigned(temp_hash),8));
end loop;
--sim_hash<= temp_hash_c;
if((target) > (temp_hash_c)  ) then--doroste ke target va hash _output be little endian hastand amma na msavi yeksan ast
nonce_vict <= nonce;
vict <='1';
elsif(nonce = nonce_end_add) then
nores <= '1';
else
--nonce_var := nonce(7 downto 0)& nonce(15 downto 8)& nonce(23 downto 16)& nonce(31 downto 24 );
--nonce_var := std_logic_vector( unsigned(nonce_var)+1);
--nonce     <= nonce_var(7 downto 0)& nonce(15 downto 8)& nonce(23 downto 16)& nonce(31 downto 24 );--in karha niaz nist chon be har hal nonce yek adade tasadofi ast
nonce <= std_logic_vector(unsigned(nonce)+1);
state     <= reset_s;
reset_sha <='1';
end if;

یک شبیه سازی برای تست برنامه ی بالا نوشته شده که از یک nonce نزدیک به nonce  موفقیت آمیز شروع می شود تا یک شدن victory را شاهد باشیم .
همچنین یک بار انتهای nonce را نرسیده به nonce موفقیت آمیز قرار می دهیم تا 1 شدن nores را شاهد باشیم.

stimulus: process
begin

wait for clk_period * 2;

-- Reset the module:
enable <= '0';
wait for clk_period;
enable <= '1';
wait for clk_period;

-- The module should now be ready for work:
nonce_end_add <= x"5d2c4310";

-- Start hashing the first test data:
next_block <= '1';
wait until i_got_next ='1';
next_block <= '0';
در بالا ساخت پالس ساعت دیده می شود و سپس انجام یک ریست انجام می شود و مقدار حداکثر nonce   بالا تر از nonce موفقیت آمیز قرار داده شده تا victory  قابل مشاهده باشد.
wait for clk_period;
wait for clk_period;
-- The module should now be ready for work:
nonce_end_add <= x"5d2c430a";

-- Start hashing the first test data:
next_block <= '1';
wait until i_got_next ='1';
next_block <= '0';

wait until nores='1' or vict ='1';

assert vict ='1'
report "victory";
assert nores ='1'
report "no resault";
wait for clk_period;
wait for clk_period;
در بالا حداکثر nonce  مقداری پایین تر از nonce  موفقیت آمیز قرار داده شده تا در شبیه سازی nores را شاهد باشیم.
و نتیجه ی شبیه سازی :
 
شکل 6-28 شبیه سازی برنامه ی top_sha
در بالا 1 شدن victory  را شاهد هستیم.
اگر کمی شبیه سازی را جلو ببریم :
 
شکل 6-29 ادامه شبیه سازی برنامه ی top_sha
در بالا 1 شدن nores را شاهد هستیم.
در نهایت این کد ها را می توان در پروژه ای بزرگتر استفاده کرد و تعدادی هشر را در کنار هم قرار داد تا به صورت موازی عملیات ماینینگ را به جلو براند .
